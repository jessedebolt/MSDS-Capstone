---
title: "MSDS 2023 Capstone Project"
author: "Jesse DeBolt & Isaac Johnson"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
  word_document: default
subtitle: Primary Document for all code
---

#.
# Setup
#.

### Load libraries and knit setup
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

# Load the necessary libraries
library(httr)
library(readr)
library(tidyverse)
library(gdata)
library(skimr)
library(DataExplorer)
library(GGally)
library(caret)
library(e1071)

```


### Files located in the GitHub repository data folder
```{r}
# File names list
filenames <- c("SEED-UR-Urban-Rural.csv",
               "SEED-SE-Unemployment_Rate.csv",
#              "SEED-SE-Severe_Housing_Cost_Burden.csv", #REMOVE, not relevant.
               "SEED-SE-Poverty.csv",
               "SEED-SE-Median_Household_Income.csv",
               "SEED-SE-Median_Home_Value.csv",
#              "SEED-SE-Income_Inequality.csv", #REMOVE, SEED-SE-Poverty.csv acts as proxy.
               "SEED-SE-Food_Stamp_SNAP_recipients.csv",
#              "SEED-SE-Education-LessThanHighSchool.csv", #REMOVE, SEED-SE-Education-LessThanCollege.csv acts as proxy.
               "SEED-SE-Education-LessThanCollege.csv",
#              "SEED-SE-Computer.csv", #REMOVE, SEED-SE-Broadband.csv acts as proxy.
               "SEED-SE-Broadband.csv",
               "SEED-PE-Park_Access.csv",
               "SEED-PE-Air_Quality.csv",
               "RF-Smoking.csv",
               "RF-Physical_Inactivity.csv",
               "RF-Obesity.csv",
               "RF-High_Cholesterol.csv",
               "RF-Diagnosed_Diabetes.csv",
               "Prev-Stroke.csv",
               "Prev-High_Blood_Pressure.csv",
               "Prev-Coronary_Heart_Disease.csv",
               "HCDI-PS-PCP.csv",
#              "HCDI-PS-Neurosurgeons.csv", #REMOVE, not relevant.
#              "HCDI-PS-Neurologists.csv", #REMOVE, not relevant.
               "HCDI-PS-CDP.csv",
               "HCDI-Insurance-Health_Insurance_Status.csv", 
               "HCDI-HP-Pharmacies_and_Drug_Stores.csv",
#              "HCDI-HP-Hospitals-Services-NS.csv", #REMOVE, not relevant.
               "HCDI-HP-Hospitals-Services-ED.csv",
               "HCDI-HP-Hospitals-Services-CIC.csv",
               "HCDI-HP-Hospitals-Services-CR.csv",
               "HCDI-HP-Hospitals.csv",
               "HCDI-CRU-Participation_Among_Eligible.csv",
               "HCDI-CRU-Eligibility_Rate.csv",
               "HCDI-CLM-Nonadherence.csv",
               "HCDI-Cholesterol_Screening.csv",
               "HCDI-BPM-Medication_Use.csv",
               "Demo-Total_Population.csv",
               "Demo-Age65Plus.csv",
               "Demo-AIAN.csv",
               "Demo-AIANmen.csv",
               "Demo-AIANwomen.csv",
               "Demo-ANHPI.csv",
               "Demo-ANHPImen.csv",
               "Demo-ANHPIwomen.csv",
               "Demo-Black.csv",
               "Demo-BlackMen.csv",
               "Demo-BlackWomen.csv",
               "Demo-Hispanic.csv",
               "Demo-HispanicMen.csv",
               "Demo-HispanicWomen.csv",
               "Demo-OtherRace.csv",
               "Demo-OtherRaceMen.csv",
               "Demo-OtherRaceWomen.csv",
               "Demo-PopAllGenders.csv",
               "Demo-PopMen.csv",
               "Demo-PopWomen.csv",
               "Demo-TwoPlus.csv",
               "Demo-TwoPlusMen.csv",
               "Demo-TwoPlusWomen.csv",
               "Demo-White.csv",
               "Demo-WhiteMen.csv",
               "Demo-WhiteWomen.csv"
               )

```


### Create a function to generate the URL for a given filename
```{r}
generate_url <- function(filename) {
  return(paste0("https://raw.githubusercontent.com/jessedebolt/MSDS-Capstone/main/data_raw/", filename))
}

```


### Generate urls for each filename
```{r}
urls <- sapply(filenames, generate_url)

```


### Read the CSV files into a list of data frames
```{r }
# Read the CSV files into a list of data frames
df_list <- lapply(urls, read_csv)

# Create names for the list items (remove the .csv from the filenames)
names(df_list) <- sapply(filenames, function(filename) gsub(".csv", "", filename))

# Create individual data frames
list2env(df_list, .GlobalEnv)

```


### Merge all sets together into one data frame
```{r}
# Get all the data frame names in the global environment
df_names <- ls(.GlobalEnv)

# Initialize an empty data frame for the final result
cdc <- data.frame()

# Loop through each data frame
for (df_name in df_names) {
  
  # Get the data frame
  df <- get(df_name, envir = .GlobalEnv)
  
  # Check if 'cnty_fips' and 'display_name' exist in the data frame
  if(all(c("cnty_fips", "display_name") %in% colnames(df))){
    
    # Convert 'cnty_fips' column to character type
    df$cnty_fips <- as.character(df$cnty_fips)
    
    # Select all columns excluding those with "theme_range" in their name
    df <- df %>%
      select(-contains("theme_range"))

    # Rename each variable, except 'cnty_fips' and 'display_name', to include the data frame name
    df <- df %>%
      rename_with(.cols = -c(cnty_fips, display_name),
                  .fn = ~ paste(df_name, ., sep = "_"))
    
    # Join the data frame with the final data frame
    if (nrow(cdc) == 0){
      cdc <- df
    } 
    else {
      cdc <- full_join(cdc, df, by = c("cnty_fips", "display_name"))
      
      # Remove the ".x" from the column names
      names(cdc) <- gsub("\\.x$", "", names(cdc))
      
      # Remove the "_Value" from the column names
      names(cdc) <- gsub("\\_Value$", "", names(cdc))
    }
  }
}

```


### Renaming variables
```{r}
# Mapping of original names to new names
name_mapping <- c("cnty_fips" = "fips",
                  "display_name" = "display_name",
                  "SEED-UR-Urban-Rural" = "UrbanRural",
                 "SEED-SE-Unemployment_Rate" = "Unemploy",
#                 "SEED-SE-Severe_Housing_Cost_Burden"= "HouseCostBurd",
                 "SEED-SE-Poverty" = "Poverty",
                 "SEED-SE-Median_Household_Income" = "MedHouseIncome",
                 "SEED-SE-Median_Home" = "MedHomeValue",
#                 "SEED-SE-Income_Inequality" = "IncomeInequality",
                 "SEED-SE-Food_Stamp_SNAP_recipients" = "SNAPrecipients",
#                 "SEED-SE-Education-LessThanHighSchool" = "EdLessHigh",
                 "SEED-SE-Education-LessThanCollege" = "EdLessColl",
#                 "SEED-SE-Computer" = "Computer",
                 "SEED-SE-Broadband" = "Broadband",
                 "SEED-PE-Park_Access" = "Parks",
                 "SEED-PE-Air_Quality" = "AirQuality",
                 "RF-Smoking" = "Smoker",
                 "RF-Physical_Inactivity" = "PhysInactivity",
                 "RF-Obesity" = "Obesity",
                 "RF-High_Cholesterol" = "HighChol",
                 "RF-Diagnosed_Diabetes" = "Diabetes",
                 "Prev-Stroke" = "Stroke",
                 "Prev-High_Blood_Pressure" = "HighBP",
                 "Prev-Coronary_Heart_Disease" = "CHD",
                 "HCDI-PS-PCP" = "PrimaryCarePhys",
#                 "HCDI-PS-Neurosurgeons" = "NeuroSurgeons",
#                 "HCDI-PS-Neurologists" = "Neurologists",
                 "HCDI-PS-CDP" = "CardioPhys",
                 "HCDI-Insurance-Health_Insurance_Status" = "HealthIns",
                 "HCDI-HP-Pharmacies_and_Drug_Stores" = "Pharmacies",
#                 "HCDI-HP-Hospitals-Services-NS" = "HospNeuro",
                 "HCDI-HP-Hospitals-Services-ED" = "HospED",
                 "HCDI-HP-Hospitals-Services-CIC" = "HospCIC",
                 "HCDI-HP-Hospitals-Services-CR" = "HospCR",
                 "HCDI-HP-Hospitals" = "Hospitals",
                 "HCDI-CRU-Participation_Among_Eligible" = "cruParticipate",
                 "HCDI-CRU-Eligibility_Rate" = "CholMedElegible",
                 "HCDI-CLM-Nonadherence" = "CholMedNonAdhear",
                 "HCDI-Cholesterol_Screening" = "CholScreen",
                 "HCDI-BPM-Medication_Use" = "bpmUse",
                 "Demo-Total_Population" = "pop",
                 "Demo-Age65Plus" = "Age65Plus",
                 "Demo-AIAN" = "AIAN",
                 "Demo-AIANmen" = "AIANmen",
                 "Demo-AIANwomen" = "AIANwomen",
                 "Demo-ANHPI" = "ANHPI",
                 "Demo-ANHPImen" = "ANHPImen",
                 "Demo-ANHPIwomen" = "ANHPIwomen",
                 "Demo-Black" = "Black",
                 "Demo-BlackMen" = "BlackMen",
                 "Demo-BlackWomen" = "BlackWomen",
                 "Demo-Hispanic" = "Hispanic",
                 "Demo-HispanicMen" = "HispanicMen",
                 "Demo-HispanicWomen" = "HispanicWomen",
                 "Demo-OtherRace" = "OtherRace",
                 "Demo-OtherRaceMen" = "OtherRaceMen",
                 "Demo-OtherRaceWomen" = "OtherRaceWomen",
                 "Demo-PopAllGenders" = "PopAllGenders",
                 "Demo-PopMen" = "PopMen",
                 "Demo-PopWomen" = "PopWomen",
                 "Demo-TwoPlus" = "TwoPlus",
                 "Demo-TwoPlusMen" = "TwoPlusMen",
                 "Demo-TwoPlusWomen" = "TwoPlusWomen",
                 "Demo-White" = "White",
                 "Demo-WhiteMen" = "WhiteMen",
                 "Demo-WhiteWomen" = "WhiteWomen"
                  )

# Get the column names of the data frame
original_names <- colnames(cdc)

# Find the corresponding new names using the mapping
new_names <- name_mapping[match(original_names, names(name_mapping))]

# Rename the variables in the data frame
colnames(cdc) <- new_names

# Clean up global environment
keep(cdc, sure = TRUE)

```


### Read in data for table descriptions
```{r}
TableDesc <- read_csv("data_support/Table_Descriptions.csv")

```

#.
# Data Cleaning
#.

### Removing US territories
```{r}
#Use if needed to back up changes
#cdc <- cdc_copy

#Remove territories
cdc <- cdc %>%
  filter(!grepl("\\(AS\\)|\\(GU\\)|\\(MP\\)|\\(PR\\)|\\(County Equivalent\\)", as.character(display_name)))

```


### Separated County and State
```{r}
# Separate the 'display_name' column
cdc <- cdc %>% separate(display_name, into = c("county", "state"), sep = ", \\(|\\)", remove = TRUE, convert = TRUE)

# Remove the closing parenthesis from the state column
cdc$state <- gsub("\\)", "", cdc$state)

# Remove the quotation marks from the 'county' column
cdc$county <- gsub("\"", "", cdc$county)

print(cdc)

```


### Make backup and display first few rows
```{r}
cdc_copy <- cdc

head(cdc)

#cdc <- cdc_copy

```


### Relabeling Urban/Rural codes
```{r}
#change rural/urban
# 1 = Large central metro -> Large_Urban
# 2 = Large fringe metro -> LargeFringe_Urban
# 3 = Medium/small metro -> MediumSmall_Urban
# 4 = Nonmetro -> Rural

cdc$"UrbanRural" <-
    ifelse(cdc$"UrbanRural" == 1,
           "Large_Urban",
    ifelse(cdc$"UrbanRural" == 2,
           "LargeFringe_Urban",
    ifelse(cdc$"UrbanRural" == 3,
           "MediumSmall_Urban",
    ifelse(cdc$"UrbanRural" == 4,
           "Rural",
           cdc$"UrbanRural"))))

### Replacing '-1' with 'NA' under assumption that these are truly missing elements
cdc[cdc == -1] <- NA

```


### Review header names, check for missing rural/urban values
```{r}
names(cdc)

unique(cdc$'UrbanRural')

rural_query <- filter(cdc, `UrbanRural` %in% c(NA, "", "NA"))

head(rural_query, n=20)

```


### Inserting Rural/Urban for missing value
```{r}
# Find and insert where county is 'Kusilvak' based on Wikipedia data.
cdc$"UrbanRural"[grepl("Kusilvak", cdc$county)] <- "Rural"

unique(cdc$'UrbanRural')

# Double check for any NAs in Rural/Urban
rural_query <- filter(cdc, `UrbanRural` %in% c(NA, "", "NA"))
head(rural_query, n=20)

```


### Inserting Parks missing value
```{r}
# Find and insert where county is 'Kusilvak' based on average for all AK counties.
cdc$"Parks"[grepl("Kusilvak", cdc$county)] <- 66

```


### Checking for missing values
```{r}
#total number of missing values in dataset
sum(is.na(cdc))

#total number of missing values in each column
colSums(is.na(cdc))

#total number of missing values in each column
count_na_func <- function(x) sum(is.na(x)) 
cdc <- cdc %>%
  mutate(count_na = apply(., 1, count_na_func)) %>% 
  arrange(desc(count_na))

```


### Remove counties with minimal data
```{r}
# Remove those that have more than 8 NAs in that row
cdc <- cdc[cdc$count_na <= 8, ]

# Remove count_na column
cdc$count_na <- NULL

```


## Populating missing values
## Single value entry
### Inserting value for missing values in bpmUse for NJ
```{r}
# Find NAs and replace where state is 'NJ'
cdc$"bpmUse"[grepl("NJ", cdc$state)] <- 71.71

```
Source: Average of NJ Cities from
500_Cities: Taking medicine for high blood pressure control among adults aged >=18 Years with high blood pressure
File: 500_Cities__Taking_medicine_for_high_blood_pressure_control_among_adults_aged___18_years_with_high_blood_pressure.csv
Source: https://chronicdata.cdc.gov/500-Cities-Places/500-Cities-Taking-medicine-for-high-blood-pressure/4peq-qp55


### Inserting value for missing values in CholScreen for NJ
```{r}
# Find NAs and replace where state is 'NJ'
cdc$"CholScreen"[grepl("NJ", cdc$state)] <- 79.43

```
Source: Average of NJ Cities from
500 Cities: Cholesterol screening among adults aged >=18 years
FIle: 500_Cities__Cholesterol_screening_among_adults_aged___18_years.csv
Source: https://chronicdata.cdc.gov/500-Cities-Places/500-Cities-Cholesterol-screening-among-adults-aged/myk4-ptre


### Inserting value for missing values in HighBP for NJ
```{r}
# Find NAs and replace where state is 'NJ'
cdc$"HighBP"[grepl("NJ", cdc$state)] <- 33.7

```
Source: Average of NJ Cities from
500 Cities: High blood pressure among adults aged >=18 years
File: 500_Cities__High_blood_pressure_among_adults_aged___18_years.csv
Source: https://chronicdata.cdc.gov/500-Cities-Places/500-Cities-High-blood-pressure-among-adults-aged-1/ebxs-yc6e


### Inserting value for missing values in Diabetes for NJ
```{r}
# Find NAs and replace where state is 'NJ'
cdc$"Diabetes"[grepl("NJ", cdc$state)] <- 17.4

```
Source: Average of NJ Cities from
500 Cities: Diagnosed diabetes among adults aged >=18 years
File: 500_Cities__Diagnosed_diabetes_among_adults_aged___18_years.csv
Source: https://chronicdata.cdc.gov/500-Cities-Places/500-Cities-Diagnosed-diabetes-among-adults-aged-18/cn78-b9bj


### Inserting value for missing values in HighChol for NJ
```{r}
# Find NAs and replace where state is 'NJ'
cdc$"HighChol"[grepl("NJ", cdc$state)] <- 32.41

```
Source: Average of NJ Cities from
500 Cities: High cholesterol among adults aged >=18 years who have been screened in the past 5 years
File:500_Cities__High_cholesterol_among_adults_aged___18_years_who_have_been_screened_in_the_past_5_years.csv
Source: https://chronicdata.cdc.gov/500-Cities-Places/500-Cities-High-cholesterol-among-adults-aged-18-y/mc6z-sjie


### Inserting value for missing values in Obesity for NJ
```{r}
# Find NAs and replace where state is 'NJ'
cdc$"Obesity"[grepl("NJ", cdc$state)] <- 33.59

```
Source: Average of NJ Cities from
500 Cities: Obesity among adults aged >=18 years
File: 500_Cities__Obesity_among_adults_aged___18_years.csv
Source: https://chronicdata.cdc.gov/500-Cities-Places/500-Cities-Obesity-among-adults-aged-18-years/bjvu-3y7d


### Inserting values for missing values in Median Home Value
```{r}
cdc$"MedHomeValue"[grepl("48261", cdc$fips)] <- 42550
cdc$"MedHomeValue"[grepl("48301", cdc$fips)] <- 38143
cdc$"MedHomeValue"[grepl("46017", cdc$fips)] <- 101393
cdc$"MedHomeValue"[grepl("46095", cdc$fips)] <- 60537

```
Reference:
Kenedy TX (fips 48261): Median Home Value = $42,550
https://www.city-data.com/county/Kenedy_County-TX.html
Loving TX (fips 48301): Median Home Value = $38,143
http://www.city-data.com/county/Loving_County-TX.html
Buffalo SD (fips 46017): Median Home Value = $101,393
http://www.city-data.com/county/Buffalo_County-SD.html
Mellette SD (fips 46095): Median Home Value = $60,537
http://www.city-data.com/county/Mellette_County-SD.html


## Multiple value entry
### Read in additional data
```{r}
pcp_cardio_count <- read_csv("data_support/pcp_cardio_count.csv")

pcp_cardio_count$COUNTY = as.character(pcp_cardio_count$COUNTY)

```


### Populating missing items for PCPs and Cardio Phys
```{r}
# Joining count data frame to the cdc data frame
cdc <- left_join(cdc, pcp_cardio_count, by = c("fips" = "COUNTY"))

# Use coalesce to replace NAs in PCP and CardioPhys
cdc <- cdc %>% 
  mutate(
    pcp = coalesce(pcp, PrimaryCarePhys),
    CardioPhys = coalesce(CardioPhys, cardio)
  )

# Remove the temporary columns
cdc <- cdc %>% select(-PrimaryCarePhys, -cardio)

```


## Imputations
### Test (automated) imputing of data that is still missing
```{r}
# Handling missing values (assuming you want to impute them)
library(mice)
imputed_data <- mice(cdc, m = 5)  # Impute missing values (replace 'data' with your dataset)

# Encoding categorical variables (assuming 'urban_rural' is a categorical variable)
#imputed_data$UrbanRural <- as.factor(imputed_data$UrbanRural)

```


### Impute remaining missing Cardiologists and Primary Care Physicians based on median of urban/rural for each state
```{r}
# Calculate medians and impute NAs
cdc <- cdc %>%
  group_by(state) %>%
  group_by(UrbanRural) %>% 
  mutate(
    CardioPhys = replace_na(CardioPhys, median(CardioPhys, na.rm = TRUE)),
    pcp = replace_na(pcp, median(pcp, na.rm = TRUE))
  )
```


### Imputing missing values in CholMedNonAdhear based on median of urban/rural for each state
```{r}
cdc = cdc %>%
  group_by(state) %>%
  group_by(UrbanRural) %>% 
  mutate(CholMedNonAdhear = replace_na(CholMedNonAdhear, median(CholMedNonAdhear, na.rm=TRUE)))

```


### Imputing missing values in CholMedElegible based on median of urban/rural for each state
```{r}
cdc = cdc %>% 
  group_by(state) %>%
  group_by(UrbanRural) %>% 
  mutate(CholMedElegible = replace_na(CholMedElegible, median(CholMedElegible, na.rm=TRUE)))

```


### Imputing missing values in cruParticipate based on median of urban/rural for each state
```{r}
cdc = cdc %>% 
  group_by(state) %>%
  group_by(UrbanRural) %>% 
  mutate(cruParticipate = replace_na(cruParticipate, median(cruParticipate, na.rm=TRUE)))

```


### Imputing missing values in PhysInactivity based on median of urban/rural for each state
```{r}
cdc = cdc %>% 
  group_by(state) %>%
  group_by(UrbanRural) %>% 
  mutate(PhysInactivity = replace_na(PhysInactivity, median(PhysInactivity, na.rm=TRUE)))

```


### Imputing missing values in AirQuality based on median of urban/rural for each state
```{r}
cdc = cdc %>% 
  group_by(state) %>%
  group_by(UrbanRural) %>% 
  mutate(AirQuality = replace_na(AirQuality, median(AirQuality, na.rm=TRUE)))

```


### Checking for missing values
```{r}
#total number of missing values in dataset
sum(is.na(cdc))

#total number of missing values in each column
colSums(is.na(cdc))

```

#.
# Feature Engineering
#.

## Convert provider demographics
### Convert number of hospitals per county to number of hospitals per 100k residents
```{r}
# Create column for number of hospitals per 100k residents
cdc$Hosp100k <- (cdc$Hospitals / cdc$pop) * 100000

```


### Convert number of pharmacies per population to number of pharmacies per 100k residents
```{r}
# Create column for number of hospitals per 100k residents
cdc$Pharm100k <- (cdc$Pharmacies / cdc$pop) * 100000

```


### Convert population per physicians to physician per 1k residents
```{r}
# Calculate the number of physicians
cdc$TotalPCP <- cdc$pop / cdc$pcp
# Create columns for number of physicians per 1k residents
cdc$PSP1k <- (cdc$TotalPCP / cdc$pop) * 1000

```


### Convert population per cardiovascular physicians to cardiovascular physician per 100k residents
```{r}
# Calculate the number of physicians
cdc$TotalCardio <- cdc$pop / cdc$CardioPhys
# Create columns for number of physicians per 1k residents
cdc$Cardio100k <- (cdc$CardioPhys / cdc$pop) * 100000

```


### Rearrange column layout
```{r}
# Define order of columns
order = c("fips", "county", "state", "UrbanRural", "CHD",
"HighBP", "HighChol", "Stroke", "Diabetes", "Obesity",
"PhysInactivity", "Smoker", "Age65Plus","CholScreen",
"CholMedNonAdhear", "CholMedElegible", "cruParticipate",
"bpmUse", "MedHouseIncome", "Poverty", "Unemploy",
"SNAPrecipients", "EdLessColl", "MedHomeValue",
"HealthIns", "AirQuality", "Parks", "Broadband","pcp",
"TotalPCP", "PSP1k", "CardioPhys", "TotalCardio",
"Cardio100k", "Hospitals", "Hosp100k", "HospCR", 
"HospCIC", "HospED", "Pharmacies", "Pharm100k", "pop",
"PopAllGenders", "PopMen", "PopWomen", "AIAN","AIANmen",
"AIANwomen", "ANHPI", "ANHPImen", "ANHPIwomen", "Black",
"BlackMen", "BlackWomen", "Hispanic", "HispanicMen",
"HispanicWomen", "TwoPlusWomen", "TwoPlus", "TwoPlusMen",
"OtherRace", "OtherRaceMen", "OtherRaceWomen", "White",
"WhiteMen", "WhiteWomen")	

# Invoke column reorganization
cdc <- cdc[, order]		

```


## Additional feature engineering
### One-hot encoding for the 'state' and 'UrbanRural' columns
```{r}
# Convert urban/rural variables to factors
cdc$UrbanRural <- as.factor(cdc$UrbanRural)

# Use fastDummies for the 'UrbanRural' column
cdc <- fastDummies::dummy_cols(cdc, select_columns = 'UrbanRural')

# Use fastDummies for the 'state' column
cdc <- fastDummies::dummy_cols(cdc, select_columns = 'state')

```


## Export cleaned data to csv
```{r}
# Write data to local in csv format
write_csv(cdc, "data/CDC_all.csv")  

```

#.
# Exploratory Data Analysis (EDA)
#.

## General Information
### Show basic details and information
```{r}
head(cdc)
str(cdc)
dim(cdc)
summary(cdc)

```


### Additional details
```{r}
skim(cdc)

```


#### What is distribution of Urban Rural for Each State
```{r}
#We should maybe bucket these? but not sure if we need to keep as is for model?
urbanrural_counts <- cdc %>%
  group_by(state, UrbanRural) %>%
  summarise(count = n()) %>%
  ungroup() %>%
  arrange(state, desc(UrbanRural)) %>%
  pivot_wider(names_from = UrbanRural, values_from = count, values_fill = 0)

# Define the desired column order
column_order <- c("Large_Urban", "LargeFringe_Urban", "MediumSmall_Urban", "Rural")

# Reorder the columns
urbanrural_counts <- urbanrural_counts %>%
  select(state, all_of(column_order))

print(urbanrural_counts)
```


#### Visualization - Stacked Bar
```{r}
urbanrural_counts <- cdc %>%
  group_by(state, UrbanRural) %>%
  summarise(count = n()) %>%
  ungroup()

ggplot(urbanrural_counts, aes(x = state, y = count, fill = UrbanRural)) +
  geom_bar(stat = "identity") +
  labs(title = "Distribution of UrbanRural Variable by State",
       x = "State", y = "Count") +
  scale_fill_discrete(name = "UrbanRural") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```


#### Visualization Bar
```{r}
urbanrural_counts <- cdc %>%
  group_by(state, UrbanRural) %>%
  summarise(count = n()) %>%
  ungroup()

ggplot(urbanrural_counts, aes(x = state, y = count, fill = UrbanRural)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Distribution of UrbanRural Variable by State",
       x = "State", y = "Count") +
  scale_fill_discrete(name = "UrbanRural") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```


#### Top 5 states with most Urban
```{r}
top_large_urban <- cdc %>%
  filter(UrbanRural == "Large_Urban") %>%
  group_by(state) %>%
  summarise(count = n()) %>%
  arrange(count) %>%
  slice_tail(n = 5) %>%
  mutate(state = factor(state, levels = rev(state)))

ggplot(top_large_urban, aes(x = state, y = count, fill = state)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = count), vjust = -0.5) +
    labs(title = "Top 5 States with the Most Large Urban Areas",
       x = "State", y = "Count") +
  scale_fill_brewer(palette = "Dark2") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))


```


#### Top 10 states with most Rural
```{r}
top_rural <- cdc %>%
  filter(UrbanRural == "Rural") %>%
  group_by(state) %>%
  summarise(count = n()) %>%
  arrange(count) %>%
  slice_tail(n = 10) %>%
  mutate(state = factor(state, levels = rev(state)))

custom_colors <- c("#FF5733", "#FFC300", "#C70039", "#900C3F", "#581845", "#FF7F50", "#FFA500", "#FFD700", "#ADFF2F", "#00FF00")

ggplot(top_rural, aes(x = state, y = count, fill = state)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = count), vjust = -0.5) +
  labs(title = "Top 10 States with the Most Rural Areas",
       x = "State", y = "Count") +
  scale_fill_manual(values = custom_colors) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```


#### I like this one better I think
```{r}
# Reverse the color palette
color_func <- colorRampPalette(c("lightblue", "darkblue"))
custom_colors <- rev(color_func(10))

top_rural <- cdc %>%
  filter(UrbanRural == "Rural") %>%
  group_by(state) %>%
  summarise(count = n()) %>%
  arrange(count) %>%
  slice_tail(n = 10) %>%
  mutate(state = factor(state, levels = rev(state)))

ggplot(top_rural, aes(x = state, y = count, fill = state)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = count), vjust = -0.5) +
  labs(title = "Top 10 States with the Most Rural Areas",
       x = "State", y = "Count") +
  scale_fill_manual(values = custom_colors) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```


#### Top 10 states with most Large Fringe Urban
```{r}
# Create the color palette
color_func <- colorRampPalette(c("lightblue", "darkblue"))
custom_colors <- rev(color_func(10))  # Reverse to get dark colors for higher values

top_large_fringe_urban <- cdc %>%
  filter(UrbanRural == "LargeFringe_Urban") %>%
  group_by(state) %>%
  summarise(count = n()) %>%
  arrange(count) %>%
  slice_tail(n = 10) %>%
  mutate(state = factor(state, levels = rev(state)))

ggplot(top_large_fringe_urban, aes(x = state, y = count, fill = state)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = count), vjust = -0.5) +
  labs(title = "Top 10 States with the Most Large Fringe Urban Areas",
       x = "State", y = "Count") +
  scale_fill_manual(values = custom_colors) +  # Use the custom color palette
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```


#### Medium Small Urban Areas
```{r}
# Create the color palette
color_func <- colorRampPalette(c("lightblue", "darkblue"))
custom_colors <- rev(color_func(10))  # Reverse to get dark colors for higher values

top_large_fringe_urban <- cdc %>%
  filter(UrbanRural == "MediumSmall_Urban") %>%
  group_by(state) %>%
  summarise(count = n()) %>%
  arrange(count) %>%
  slice_tail(n = 10) %>%
  mutate(state = factor(state, levels = rev(state)))

ggplot(top_large_fringe_urban, aes(x = state, y = count, fill = state)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = count), vjust = -0.5) +
  labs(title = "Top 10 States with the Most Medium Small Urban Areas",
       x = "State", y = "Count") +
  scale_fill_manual(values = custom_colors) +  # Use the custom color palette
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

```


### Correlations
```{r}
plot_correlation(cdc)

#tried this but needed to remove non numerical first
correlation_matrix <- cdc %>% select(-c(fips, county, state, "UrbanRural")) %>% cor()

#install.packages("reshape2")
library(reshape2)

melted_cor <- melt(correlation_matrix)

ggplot(data = melted_cor, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  scale_fill_gradient(low = "blue", high = "red") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Correlation Heatmap")

#focused on looking at high correlations only
high_correlations <- subset(melt(correlation_matrix), value > 0.75 & value < 1)

ggplot(data = high_correlations, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  scale_fill_gradient(low = "blue", high = "red") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "High Correlation Heatmap (Correlation > 0.75)")

#focused on medium high correlations
mid_correlations <- subset(melt(correlation_matrix), value > 0.50 & value < 0.75)

ggplot(data = mid_correlations, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  scale_fill_gradient(low = "blue", high = "red") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Mid Correlation Heatmap (0.50 < Correlation < 0.75)")


#looked at Urban Rural vs CHD
ggplot(data = cdc, aes(x = `UrbanRural`, y = `CHD`, fill = `UrbanRural`)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "UrbanRural", y = "Prevalence of CHD", fill = "UrbanRural") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```


#### Negative Correlations
```{r}
# focused on looking at negative high correlations only
neg_high_correlations <- subset(melt(correlation_matrix), value < -0.75 & value > -1)

ggplot(data = neg_high_correlations, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  scale_fill_gradient(low = "blue", high = "red") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "High Correlation Heatmap (Correlation < -0.75)")

# focused on negative medium high correlations
neg_mid_correlations <- subset(melt(correlation_matrix), value < -0.50 & value > -0.75)

ggplot(data = neg_mid_correlations, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  scale_fill_gradient(low = "blue", high = "red") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Mid Correlation Heatmap (-0.75 < Correlation < -0.50)")

```


### Top 10 Counties with highest CHD prevalence
```{r}
highest_10 <- cdc %>%
  arrange(desc(CHD)) %>%
  head(10)
highest_10

```


### Bottom 10 Counties with lowest CHD prevalence
```{r}

lowest_10 <- cdc %>%
#    filter("CHD" != -1) %>%
    arrange(CHD) %>%
    head(10)
lowest_10

```


### How many counties per state
```{r}
county_counts <- cdc %>%
  group_by(state) %>%
  summarise(counties = n())

print(county_counts)

```


### Outliers
```{r}

cdc_comp <- cdc %>% 
  select(-c("fips", "county", "state", "UrbanRural"))

# Outlier detection
for (column in colnames(cdc_comp)){
  IQR = IQR(cdc_comp[[column]], na.rm = TRUE)
  lower_bound = quantile(cdc_comp[[column]], 0.25, na.rm = TRUE) - 1.5 * IQR
  upper_bound = quantile(cdc_comp[[column]], 0.75, na.rm = TRUE) + 1.5 * IQR
  outliers = length(which(cdc_comp[[column]] < lower_bound | cdc_comp[[column]] > upper_bound))
  print(paste("Number of outliers in", column, ":", outliers))
}
```


### Proportion for each level of Urban Rural
```{r}
# proportion of each level 'UrbanRural'
urban_rural_proportions <- cdc %>%
  group_by(UrbanRural) %>%
  summarise(n = n()) %>%
  mutate(prop = n / sum(n))

# Print the proportions
print(urban_rural_proportions)

```


### Mean Prevalence for CHD by each level of Urban/Rural
```{r}

# Compute mean CHD prevalence for each category of UrbanRural
mean_chd <- cdc %>% 
  group_by(UrbanRural) %>% 
  summarise(mean_chd = mean(CHD))

# Print mean CHD prevalence
print(mean_chd)

```


### Look at extremes for Urban Rural
```{r}
# Find urban areas (Large_Urban, LargeFringe_Urban, MediumSmall_Urban) with high CHD
urban_high_chd <- cdc %>% 
  filter(UrbanRural %in% c('Large_Urban', 'LargeFringe_Urban', 'MediumSmall_Urban'), 
         CHD > quantile(CHD, 0.95))

# Find rural areas with low CHD
rural_low_chd <- cdc %>% 
  filter(UrbanRural == 'Rural', CHD < quantile(CHD, 0.05))

# Print the top 5 urban areas with high CHD
print(head(urban_high_chd, 5))

# Print the top 5 rural areas with low CHD
print(head(rural_low_chd, 5))
```


### Side by side of what's different between the two extremes
```{r}
# Get the names of numeric columns
numeric_columns <- names(cdc)[sapply(cdc, is.numeric)]

# Select the first 32 numeric columns
numeric_columns <- numeric_columns[1:32] #(1:32) Age95Plus:pcp

# Compute descriptive statistics for urban areas with high CHD
urban_high_chd_stats <- urban_high_chd %>%
  select(numeric_columns) %>%
  summarise_all(list(mean = mean, sd = sd), na.rm = TRUE)

# Compute descriptive statistics for rural areas with low CHD
rural_low_chd_stats <- rural_low_chd %>%
  select(numeric_columns) %>%
  summarise_all(list(mean = mean, sd = sd), na.rm = TRUE)

# Add a group indicator
urban_high_chd_stats$group <- "urban_high_chd"
rural_low_chd_stats$group <- "rural_low_chd"

# Bind the rows
combined_stats <- bind_rows(urban_high_chd_stats, rural_low_chd_stats)

# Reshape from wide to long format
long_stats <- pivot_longer(combined_stats, -group, names_to = c(".value", "statistic"), names_pattern = "(.+)_(.+)")

# Print the long format stats
print(long_stats)
```


### Determining mean and standard deviation of CHD
```{r}
# Separate the mean and standard deviation rows
mean_stats <- long_stats %>% filter(statistic == "mean")
sd_stats <- long_stats %>% filter(statistic == "sd")

# Merge the data frames by group and variable names
merged_stats <- merge(mean_stats, sd_stats, by = c("group"), suffixes = c("_mean", "_sd"))

# Plot mean and sd for CHD
ggplot(merged_stats, aes(x = group, y = CHD_mean, fill = group)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_errorbar(aes(ymin = CHD_mean - CHD_sd, ymax = CHD_mean + CHD_sd), width = 0.2, position = position_dodge(0.9)) +
  labs(title = "Mean and Standard Deviation of CHD", x = "Group", y = "Mean CHD")

```


### Boxplots for each variable
```{r}
# Create the subset
cdc_subset <- cdc %>%
  select(c(5:66))  #(5:66) All excluding state and rural/urban hot coded

# Box plots for each variable in the subset
for (i in 1:ncol(cdc_subset)) {
  par(mar = c(5, 4, 2, 1))
  boxplot(cdc_subset[, i], main = names(cdc_subset)[i])
}

```


### Comparing mean values of various features 
```{r}
# Convert data from wide to long format
long_data <- gather(merged_stats, variable, value, -group)

# Select variables
# selected_vars <- c("bpmUse", "CholScreen", "Obesity", "CholMedNonAdhear", "CholMedElegible", "cruParticipate", "Hospitals")

# selected_vars <- c("bpmUse", "CholScreen", "CholMedNonAdhear", "CholMedElegible", "cruParticipate", "Hospitals", "HospCIC", 
# "HospCR", "HospED", "Pharmacies", "CardioPhys", "PrimaryCarePhys", "CHD", "HighBP", "Stroke", "Diabetes", "HighChol", "Obesity",
# "PhysInactivity", "Smoker", "AirQuality", "Parks", "Broadband", "EdLessColl", "SNAPrecipients", "MedHomeValue", "MedHouseIncome", 
# "Poverty", "Unemploy")

selected_vars <- cdc_subset %>% names()

# Loop over selected variables
for (var in selected_vars) {
  # Filter data for this variable (mean only)
  var_data <- filter(long_data, variable == paste0(var, "_mean"))
  
  # Create bar plot
  p <- ggplot(var_data, aes(x = group, y = value, fill = group)) +
    geom_bar(stat = "identity", position = position_dodge()) +
    labs(title = paste("Comparison of", var, "between Groups"),
         x = "Group",
         y = "Value") 
  
  # Print plot
  print(p)
}

```


### Auto EDA report (from DataExplorer)
```{r}
cdc %>%
    select(c(5:66)) %>% #(5:66) All excluding state and rural/urban hot coded
    create_report(
        output_file = paste ("Auto EDA Report"),
        report_title = "EDA Report - CHD Dataset",
        y = "CHD"
    )

```


## CHD Specific EDA
### Reviewing CHD prevalence
```{r}
hist(cdc$"CHD")

#looked at Urban Rural vs CHD (Keep here? or below at line 619)
ggplot(data = cdc, aes(x = `UrbanRural`, y = `CHD`, fill = `UrbanRural`)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "UrbanRural", y = "Prevalence of CHD", fill = "UrbanRural") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```


### Boxplot to compare coronary heart disease prevalence in rural and urban areas
```{r}
ggplot(cdc, aes(x=UrbanRural, y=CHD)) + geom_boxplot()

```

### Average prevalence of CHD
```{r}
# Average prevalence for the US
us_average <- mean(cdc$CHD, na.rm = TRUE)
us_average <- sprintf("%.1f%%", us_average)

# Average prevalence for each state
state_average <- cdc %>%
  group_by(state) %>%
  summarise(average_CHD = mean(CHD, na.rm = TRUE)) %>%
  mutate(average_CHD = sprintf("%.1f%%", average_CHD))

print(us_average)
print(state_average)

```


### states with highest and lowest prevalence
```{r}

# Top 10 states with highest prevalence
highest_prevalence <- cdc %>%
  group_by(state) %>%
  summarise(average_CHD = mean(CHD, na.rm = TRUE)) %>%
  arrange(desc(average_CHD)) %>%
  slice(1:10) %>%
  mutate(average_CHD_text = sprintf("%.1f%%", average_CHD))

# Top 10 states with lowest prevalence
lowest_prevalence <- cdc %>%
  group_by(state) %>%
  summarise(average_CHD = mean(CHD, na.rm = TRUE)) %>%
  arrange(average_CHD) %>%
  slice(1:10) %>%
  mutate(average_CHD_text = sprintf("%.1f%%", average_CHD))

print(highest_prevalence)
print(lowest_prevalence)

```


### states with highest and lowest prevalence visual
```{r}

# Bar plot for highest prevalence
ggplot(highest_prevalence, aes(x = reorder(state, average_CHD), y = average_CHD)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(x = "State", y = "Average CHD Prevalence", title = "Top 10 States with Highest CHD Prevalence") +
  theme_minimal()

# Bar plot for lowest prevalence
ggplot(lowest_prevalence, aes(x = reorder(state, -average_CHD), y = average_CHD)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(x = "State", y = "Average CHD Prevalence", title = "Top 10 States with Lowest CHD Prevalence") +
  theme_minimal()

```


### Heatmap for CHD Prevalence
```{r}
# Calculate the average CHD prevalence by state and UrbanRural level
chd_prevalence_by_state_and_urbanrural <- cdc %>%
  group_by(state, UrbanRural) %>%
  summarise(average_CHD = mean(CHD, na.rm = TRUE))

# Pivot the data to have a column for each UrbanRural level
chd_prevalence_pivot <- chd_prevalence_by_state_and_urbanrural %>%
  pivot_wider(names_from = UrbanRural, values_from = average_CHD)

chd_prevalence_pivot

# Reshape data to a longer format suitable for plotting
chd_prevalence_long <- chd_prevalence_pivot %>%
  pivot_longer(cols = c(Large_Urban, LargeFringe_Urban, MediumSmall_Urban, Rural),
               names_to = "UrbanRural",
               values_to = "average_CHD")

# Generate a heatmap
ggplot(chd_prevalence_long, aes(x = state, y = UrbanRural, fill = average_CHD)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red") +
  labs(x = "State", y = "Urban/Rural Level", fill = "Average CHD Prevalence", 
       title = "Heatmap of CHD Prevalence by State and Urban/Rural Level") +
  theme(axis.text.x = element_text(angle = 90))

```


## Rural/Urban Specific EDA
### Histograms to understand distribution of various factors in rural and urban areas
#### Cardiovascular Providers
```{r}
ggplot(cdc, aes(x=CardioPhys)) + geom_histogram(binwidth=10) + facet_grid(~ UrbanRural)

```


#### Primary Care Providers
```{r}
ggplot(cdc, aes(x=pcp)) + geom_histogram(binwidth=10) + facet_grid(~ UrbanRural)

```


#### Hospitals
```{r}
ggplot(cdc, aes(x=Hospitals)) + geom_histogram(binwidth=10) + facet_grid(~ UrbanRural)

```


#### Hospitals with Cardiac Intensive Care Centers
```{r}
ggplot(cdc, aes(x=HospCIC)) + geom_histogram(binwidth=10) + facet_grid(~ UrbanRural)

```


#### Hospitals with Cardiac Rehabilitation Centers
```{r}
ggplot(cdc, aes(x=HospCR)) + geom_histogram(binwidth=10) + facet_grid(~ UrbanRural)

```


#### Pharmacies
```{r}
ggplot(cdc, aes(x=Pharmacies)) + geom_histogram(binwidth=10) + facet_grid(~ UrbanRural)

```


#### Population
```{r}
ggplot(cdc, aes(x=log(pop))) + geom_histogram(binwidth=1) + facet_grid(~ UrbanRural)

```


#### Air Quality
```{r}
ggplot(cdc, aes(x=AirQuality)) + geom_histogram(binwidth=1) + facet_grid(~ UrbanRural)

```


#### Parks
```{r}
ggplot(cdc, aes(x=Parks)) + geom_histogram(binwidth=10) + facet_grid(~ UrbanRural)

```


#### Broadband Access
```{r}
ggplot(cdc, aes(x=Broadband)) + geom_histogram(binwidth=10) + facet_grid(~ UrbanRural)

```


#### Education Less Than College
```{r}
ggplot(cdc, aes(x=EdLessColl)) + geom_histogram(binwidth=10) + facet_grid(~ UrbanRural)

```


#### Greater than 65 years old
```{r}
ggplot(cdc, aes(x=Age65Plus)) + geom_histogram(binwidth=10) + facet_grid(~ UrbanRural)

```


## Hospital Specific EDA
### Histograms for numerical variables
```{r}
for (col in c(5:66)) {  #(5:70) All numeric excluding state and rural/urban hot coded
  if (is.numeric(cdc[[col]])) {
    hist(cdc[[col]], main = names(cdc)[col])
  } else {
    message(paste("Skipping column", names(cdc)[col], "as it is not numeric."))
  }
}

```


#### Looking closer at Hospitals
```{r}
hospital_counts <- cdc$Hospitals  # Assuming "Hospitals" is the column name in the dataset "cdc"

# Filter out hospitals greater than 10 (optional, if needed)
hospital_counts <- hospital_counts[hospital_counts <= 10]

# Create a table of counts for each hospital count
count_table <- table(hospital_counts)

# Create a bar plot to visualize the breakdown
barplot(count_table, main = "Number of Hospitals per County", xlab = "Number of Hospitals", ylab = "Count")

```


#### Same as above but improved visual
```{r}
#Most counties have 1 hospital
hospital_counts <- cdc$Hospitals  # Assuming "Hospitals" is the column name in the dataset "cdc"

# Filter out hospitals greater than 10 (optional, if needed)
hospital_counts <- hospital_counts[hospital_counts <= 10]

# Create a data frame with counts for each hospital count
count_df <- data.frame(Hospitals = as.factor(hospital_counts))
count_summary <- summary(count_df$Hospitals)

# Create a bar plot using ggplot2
ggplot(count_df, aes(x = Hospitals)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Number of Hospitals per County", x = "Number of Hospitals", y = "Count") +
  scale_x_discrete(limits = as.character(0:10)) +
  theme_minimal()

```


#### How many counties have no hospitals
```{r}
# Check the count for zero hospitals
count_zero <- count_table[as.character(0)]

# Print the number of counties with zero hospitals
print(paste("Number of counties with zero hospitals:", count_zero))

```


#### List of counties with 0 hospitals
```{r}
no_hospital <- cdc %>%
  filter(Hospitals == 0) %>%
  select(county, state, Hospitals) %>%
  arrange(state, county)

print(no_hospital)


no_hospital_counts <- no_hospital %>%
  group_by(state) %>%
  summarize(count = n(), .groups = "drop") %>%
    arrange(desc(count))

print(no_hospital_counts)

```


## Diabetes Specific EDA
### Diabetes various visuals
```{r}
summary(cdc$Diabetes)
hist(cdc$"Diabetes")

# Calculate the average prevalence of Diabetes for each UrbanRural status
avg_diabetes_urbanrural <- cdc %>%
  group_by(UrbanRural) %>%
  summarise(avg_diabetes = mean(Diabetes, na.rm = TRUE))

# Print the result
print(avg_diabetes_urbanrural)

# Plot a bar graph
ggplot(avg_diabetes_urbanrural, aes(x=UrbanRural, y=avg_diabetes)) +
  geom_bar(stat='identity', fill='skyblue') +
  labs(x='UrbanRural Status', y='Average Diabetes %', title='Average Prevalence of Diabetes for Each UrbanRural Status')


#looked at CHD vs Diabetes
ggplot(data = cdc, aes(x = `CHD`, y = `Diabetes`, fill = `CHD`)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "CHD", y = "Prevalence of Diabetes", fill = "CHD") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


### Top 10 Counties with highest Diabetes prevalence
```{r}
highest_10 <- cdc %>%
  arrange(desc(Diabetes)) %>%
  head(10)
highest_10
```

### Bottom 10 Counties with lowest Diabetes prevalence
```{r}
lowest_10 <- cdc %>%
    arrange(Diabetes) %>%
    head(10)
lowest_10
```


### Correlation plots
```{r}
cdc %>%
    select("CHD",
           "UrbanRural",
           "Diabetes",
           "Obesity",
           "PhysInactivity") %>%
    ggpairs(mapping = aes(color = cdc$"UrbanRural", alpha = 0.5))

```


#### Density plot for Diabetes UrbanRural
```{r}

ggplot(cdc, aes(x = Diabetes, fill = UrbanRural)) +
  geom_density(alpha = 0.5) +
  labs(x = "Diabetes", y = "Density") +
  theme_minimal() +
  scale_fill_brewer(palette = "Dark2")

library(corrplot)

correlation_matrix <- cor(cdc[, c("Diabetes", "CHD")])
corrplot(correlation_matrix, method = "number")



# Create a plot for each UrbanRural category
for(category in unique(cdc$UrbanRural)) {
  data_subset <- subset(cdc, UrbanRural == category)

  # Calculate correlation
  correlation <- round(cor(data_subset$Diabetes, data_subset$CHD, use = "pairwise.complete.obs"), 2)

  # Create the plot
  p <- ggplot(data_subset, aes(x = Diabetes, y = CHD)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "dashed") +
    geom_text(aes(label = paste("Correlation = ", correlation), x = Inf, y = Inf), hjust = "right", vjust = "top") +
    labs(title = paste("UrbanRural category:", category), x = "Diabetes", y = "CHD") +
    theme_minimal()
  
  print(p)
}

```


### Diabetes Boxplot
```{r}
ggplot(cdc, aes(x=UrbanRural, y=Diabetes)) + geom_boxplot()

```


### Correlation analysis between Diabetes, Obesity, and physical inactivity
```{r}
cor.test(cdc$Diabetes, cdc$Obesity)
cor.test(cdc$Diabetes, cdc$PhysInactivity)
```


#### Highest and Lowest States Diabetes Prevalence
```{r}
# Top 10 states with highest prevalence
cdc %>%
    group_by(state) %>%
    summarise(avg_diabetes = mean(Diabetes, na.rm=TRUE)) %>%
    arrange(desc(avg_diabetes)) %>%
    head(10) %>%
    ggplot(aes(x=reorder(state, avg_diabetes), y=avg_diabetes)) +
    geom_bar(stat='identity', fill='skyblue') +
    coord_flip() +
    labs(x='State', y='Average Diabetes %', title='Top 10 States with Highest Prevalence of Diabetes')

# Bottom 10 states with lowest prevalence
cdc %>%
    group_by(state) %>%
    summarise(avg_diabetes = mean(Diabetes, na.rm=TRUE)) %>%
    arrange(avg_diabetes) %>%
    head(10) %>%
    ggplot(aes(x=reorder(state, avg_diabetes), y=avg_diabetes)) +
    geom_bar(stat='identity', fill='skyblue') +
    coord_flip() +
    labs(x='State', y='Average Diabetes %', title='Top 10 States with Lowest Prevalence of Diabetes')
```


## Obesity Specific EDA
### Obesity various visuals
```{r}
summary(cdc$Obesity)
hist(cdc$"Obesity")

# Calculate the average prevalence of Obesity for each UrbanRural status
avg_obesity_urbanrural <- cdc %>%
  group_by(UrbanRural) %>%
  summarise(avg_obesity = mean(Obesity, na.rm = TRUE))

# Print the result
print(avg_obesity_urbanrural)

# Plot a bar graph
ggplot(avg_obesity_urbanrural, aes(x=UrbanRural, y=avg_obesity)) +
  geom_bar(stat='identity', fill='skyblue') +
  labs(x='UrbanRural Status', y='Average Obesity %', title='Average Obesity for Each UrbanRural Status')


#looked at CHD vs Obesity
ggplot(data = cdc, aes(x = `CHD`, y = `Obesity`, fill = `CHD`)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "CHD", y = "Obesity Rates", fill = "CHD") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


### Top 10 Counties with highest Obesity prevalence
```{r}
highest_10 <- cdc %>%
  arrange(desc(Obesity)) %>%
  head(10)
highest_10
```


### Bottom 10 Counties with lowest Obesity prevalence
```{r}
lowest_10 <- cdc %>%
    arrange(Obesity) %>%
    head(10)
lowest_10
```

### Density plot for Obesity UrbanRural
```{r}

ggplot(cdc, aes(x = Obesity, fill = UrbanRural)) +
  geom_density(alpha = 0.5) +
  labs(x = "Obesity", y = "Density") +
  theme_minimal() +
  scale_fill_brewer(palette = "Dark2")

library(corrplot)

correlation_matrix <- cor(cdc[, c("Obesity", "CHD")])
corrplot(correlation_matrix, method = "number")



# Create a plot for each UrbanRural category
for(category in unique(cdc$UrbanRural)) {
  data_subset <- subset(cdc, UrbanRural == category)

  # Calculate correlation
  correlation <- round(cor(data_subset$Obesity, data_subset$CHD, use = "pairwise.complete.obs"), 2)

  # Create the plot
  p <- ggplot(data_subset, aes(x = Obesity, y = CHD)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "dashed") +
    geom_text(aes(label = paste("Correlation = ", correlation), x = Inf, y = Inf), hjust = "right", vjust = "top") +
    labs(title = paste("UrbanRural category:", category), x = "Obesity", y = "CHD") +
    theme_minimal()
  
  print(p)
}

```


### Obesity Boxplot
```{r}
ggplot(cdc, aes(x=UrbanRural, y=Obesity)) + geom_boxplot()

```


### Highest and Lowest States rates of Obesity
```{r}
# Top 10 states with highest rates
cdc %>%
    group_by(state) %>%
    summarise(avg_obesity = mean(Obesity, na.rm=TRUE)) %>%
    arrange(desc(avg_obesity)) %>%
    head(10) %>%
    ggplot(aes(x=reorder(state, avg_obesity), y=avg_obesity)) +
    geom_bar(stat='identity', fill='skyblue') +
    coord_flip() +
    labs(x='State', y='Average Obesity %', title='Top 10 States with Highest Rates of Obesity')

# Bottom 10 states with lowest rates
cdc %>%
    group_by(state) %>%
    summarise(avg_obesity = mean(Obesity, na.rm=TRUE)) %>%
    arrange(avg_obesity) %>%
    head(10) %>%
    ggplot(aes(x=reorder(state, avg_obesity), y=avg_obesity)) +
    geom_bar(stat='identity', fill='skyblue') +
    coord_flip() +
    labs(x='State', y='Average Obesity %', title='Top 10 States with Rates of Obesity')

```


## Physical Inactivity Specific EDA
### Physical Inactivity various visuals
```{r}
summary(cdc$PhysInactivity)
hist(cdc$"PhysInactivity")

# Calculate the average % Physical Inactivity for each UrbanRural status
avg_inactivity_urbanrural <- cdc %>%
  group_by(UrbanRural) %>%
  summarise(avg_inactivity = mean(PhysInactivity, na.rm = TRUE))

# Print the result
print(avg_inactivity_urbanrural)

# Plot a bar graph
ggplot(avg_inactivity_urbanrural, aes(x=UrbanRural, y=avg_inactivity)) +
  geom_bar(stat='identity', fill='skyblue') +
  labs(x='UrbanRural Status', y='Average Physical Inactivity %', title='Average Physical Inactivity for Each UrbanRural Status')


#looked at CHD vs Physical Inactivity
ggplot(data = cdc, aes(x = `CHD`, y = `PhysInactivity`, fill = `CHD`)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "CHD", y = "Rate of Physical Inactivity", fill = "CHD") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


### Top 10 Counties with highest % of Physical Inactivity
```{r}
highest_10 <- cdc %>%
  arrange(desc(PhysInactivity)) %>%
  head(10)
highest_10
```


### Bottom 10 Counties with lowest % of Physical Inactivity
```{r}
lowest_10 <- cdc %>%
    arrange(PhysInactivity) %>%
    head(10)
lowest_10
```


### Density plot for Physical Inactivity UrbanRural
```{r}

ggplot(cdc, aes(x = PhysInactivity, fill = UrbanRural)) +
  geom_density(alpha = 0.5) +
  labs(x = "PhysInactivity", y = "Density") +
  theme_minimal() +
  scale_fill_brewer(palette = "Dark2")

library(corrplot)

correlation_matrix <- cor(cdc[, c("PhysInactivity", "CHD")])
corrplot(correlation_matrix, method = "number")



# Create a plot for each UrbanRural category
for(category in unique(cdc$UrbanRural)) {
  data_subset <- subset(cdc, UrbanRural == category)

  # Calculate correlation
  correlation <- round(cor(data_subset$PhysInactivity, data_subset$CHD, use = "pairwise.complete.obs"), 2)

  # Create the plot
  p <- ggplot(data_subset, aes(x = PhysInactivity, y = CHD)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "dashed") +
    geom_text(aes(label = paste("Correlation = ", correlation), x = Inf, y = Inf), hjust = "right", vjust = "top") +
    labs(title = paste("UrbanRural category:", category), x = "PhysInactivity", y = "CHD") +
    theme_minimal()
  
  print(p)
}

```


### PhysInactivity Boxplot
```{r}
ggplot(cdc, aes(x=UrbanRural, y=PhysInactivity)) + geom_boxplot()

```


### Highest and Lowest States Rates of Physical Inactivity
```{r}
# Top 10 states with highest activity
cdc %>%
    group_by(state) %>%
    summarise(avg_inactivity = mean(PhysInactivity, na.rm=TRUE)) %>%
    arrange(desc(avg_inactivity)) %>%
    head(10) %>%
    ggplot(aes(x=reorder(state, avg_inactivity), y=avg_inactivity)) +
    geom_bar(stat='identity', fill='skyblue') +
    coord_flip() +
    labs(x='State', y='Average PhysInactivity %', title='Top 10 States with Highest Rates of Physical Inactivity')

# Bottom 10 states with lowest activity
cdc %>%
    group_by(state) %>%
    summarise(avg_inactivity = mean(PhysInactivity, na.rm=TRUE)) %>%
    arrange(avg_inactivity) %>%
    head(10) %>%
    ggplot(aes(x=reorder(state, avg_inactivity), y=avg_inactivity)) +
    geom_bar(stat='identity', fill='skyblue') +
    coord_flip() +
    labs(x='State', y='Average PhysInactivity %', title='Top 10 States with Lowest Rates of Physical Inactivity')
```


## Medication Non Adherence Specific EDA
### Medication Non Adherence various visuals
```{r}
summary(cdc$CholMedNonAdhear)
hist(cdc$"CholMedNonAdhear")

# Calculate the average rate of CholMedNonAdhear for each UrbanRural status
avg_nonadhear_urbanrural <- cdc %>%
  group_by(UrbanRural) %>%
  summarise(avg_nonadhear = mean(CholMedNonAdhear, na.rm = TRUE))

# Print the result
print(avg_nonadhear_urbanrural)

# Plot a bar graph
ggplot(avg_nonadhear_urbanrural, aes(x=UrbanRural, y=avg_nonadhear)) +
  geom_bar(stat='identity', fill='skyblue') +
  labs(x='UrbanRural Status', y='Average CholMedNonAdhear %', title='Average CholMedNonAdhear for Each UrbanRural Status')


#looked at CHD vs CholMedNonAdhear
ggplot(data = cdc, aes(x = `CHD`, y = `CholMedNonAdhear`, fill = `CHD`)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "CHD", y = "Rate of CholMedNonAdhear", fill = "CHD") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


### Top 10 Counties with highest CholMedNonAdhear
```{r}
highest_10 <- cdc %>%
  arrange(desc(CholMedNonAdhear)) %>%
  head(10)
highest_10
```


### Bottom 10 Counties with lowest CholMedNonAdhear
```{r}
lowest_10 <- cdc %>%
    arrange(CholMedNonAdhear) %>%
    head(10)
lowest_10
```


### Density plot for CholMedNonAdhear UrbanRural
```{r}

ggplot(cdc, aes(x = CholMedNonAdhear, fill = UrbanRural)) +
  geom_density(alpha = 0.5) +
  labs(x = "CholMedNonAdhear", y = "Density") +
  theme_minimal() +
  scale_fill_brewer(palette = "Dark2")

library(corrplot)

correlation_matrix <- cor(cdc[, c("CholMedNonAdhear", "CHD")])
corrplot(correlation_matrix, method = "number")



# Create a plot for each UrbanRural category
for(category in unique(cdc$UrbanRural)) {
  data_subset <- subset(cdc, UrbanRural == category)

  # Calculate correlation
  correlation <- round(cor(data_subset$CholMedNonAdhear, data_subset$CHD, use = "pairwise.complete.obs"), 2)

  # Create the plot
  p <- ggplot(data_subset, aes(x = CholMedNonAdhear, y = CHD)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "dashed") +
    geom_text(aes(label = paste("Correlation = ", correlation), x = Inf, y = Inf), hjust = "right", vjust = "top") +
    labs(title = paste("UrbanRural category:", category), x = "CholMedNonAdhear", y = "CHD") +
    theme_minimal()
  
  print(p)
}

```


### Medication Nonadherence Boxplot
```{r}
ggplot(cdc, aes(x=UrbanRural, y=CholMedNonAdhear)) + geom_boxplot()

```


### Highest and Lowest States Rates of CholMedNonAdhear
```{r}
# Top 10 states with highest CholMedNonAdhear
cdc %>%
    group_by(state) %>%
    summarise(avg_nonadhear = mean(CholMedNonAdhear, na.rm=TRUE)) %>%
    arrange(desc(avg_nonadhear)) %>%
    head(10) %>%
    ggplot(aes(x=reorder(state, avg_nonadhear), y=avg_nonadhear)) +
    geom_bar(stat='identity', fill='skyblue') +
    coord_flip() +
    labs(x='State', y='Average CholMedNonAdhear %', title='Top 10 States with Highest Rates of CholMedNonAdhear')

# Bottom 10 states with lowest CholMedNonAdhear
cdc %>%
    group_by(state) %>%
    summarise(avg_nonadhear = mean(CholMedNonAdhear, na.rm=TRUE)) %>%
    arrange(avg_nonadhear) %>%
    head(10) %>%
    ggplot(aes(x=reorder(state, avg_nonadhear), y=avg_nonadhear)) +
    geom_bar(stat='identity', fill='skyblue') +
    coord_flip() +
    labs(x='State', y='Average CholMedNonAdhear %', title='Top 10 States with Lowest Rates of CholMedNonAdhear')
```


## Health Insurance (no Health Insurance %) Specific EDA
### Health Insurance (no Health Insurance %) various visuals
```{r}
summary(cdc$HealthIns)
hist(cdc$"HealthIns")

# Calculate the average % amount of No Health Insurance for each UrbanRural status
avg_NoHealthIns <- cdc %>%
  group_by(UrbanRural) %>%
  summarise(avg_NoHealthIns = mean(HealthIns, na.rm = TRUE))

# Print the result
print(avg_NoHealthIns)

# Plot a bar graph
ggplot(avg_NoHealthIns, aes(x=UrbanRural, y=avg_NoHealthIns)) +
  geom_bar(stat='identity', fill='skyblue') +
  labs(x='UrbanRural Status', y='Average W/O Health Insurance %', title='Average % W/O Health Insurance for Each UrbanRural Status')


#looked at CHD vs No Health Insurance
ggplot(data = cdc, aes(x = `CHD`, y = `HealthIns`, fill = `CHD`)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "CHD", y = "% Rate of No Health Insurance", fill = "CHD") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


### Top 10 Counties with highest rates % of No Health Insurance
```{r}
highest_10 <- cdc %>%
  arrange(desc(HealthIns)) %>%
  head(10)
highest_10
```


### Bottom 10 Counties with lowest rates % of No Health Insurance
```{r}
lowest_10 <- cdc %>%
    arrange(HealthIns) %>%
    head(10)
lowest_10
```


### Density plot for No HealthIns UrbanRural
```{r}

ggplot(cdc, aes(x = HealthIns, fill = UrbanRural)) +
  geom_density(alpha = 0.5) +
  labs(x = "PhysInactivity", y = "Density") +
  theme_minimal() +
  scale_fill_brewer(palette = "Dark2")

library(corrplot)

correlation_matrix <- cor(cdc[, c("HealthIns", "CHD")])
corrplot(correlation_matrix, method = "number")



# Create a plot for each UrbanRural category
for(category in unique(cdc$UrbanRural)) {
  data_subset <- subset(cdc, UrbanRural == category)

  # Calculate correlation
  correlation <- round(cor(data_subset$HealthIns, data_subset$CHD, use = "pairwise.complete.obs"), 2)

  # Create the plot
  p <- ggplot(data_subset, aes(x = HealthIns, y = CHD)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "dashed") +
    geom_text(aes(label = paste("Correlation = ", correlation), x = Inf, y = Inf), hjust = "right", vjust = "top") +
    labs(title = paste("UrbanRural category:", category), x = "HealthIns", y = "CHD") +
    theme_minimal()
  
  print(p)
}

```


### HealthIns Boxplot
```{r}
ggplot(cdc, aes(x=UrbanRural, y=HealthIns)) + geom_boxplot()

```


### Highest and Lowest States Rates of No Health Insurance
```{r}
# Top 10 states with highest % No Health Insurance
cdc %>%
    group_by(state) %>%
    summarise(avg_NoHealthIns = mean(HealthIns, na.rm=TRUE)) %>%
    arrange(desc(avg_NoHealthIns)) %>%
    head(10) %>%
    ggplot(aes(x=reorder(state, avg_NoHealthIns), y=avg_NoHealthIns)) +
    geom_bar(stat='identity', fill='skyblue') +
    coord_flip() +
    labs(x='State', y='Average % No Health Insurance', title='Top 10 States with Highest Rates of No Health Insurance')

# Bottom 10 states with lowest rates % of No Health Insurance
cdc %>%
    group_by(state) %>%
    summarise(avg_NoHealthIns = mean(HealthIns, na.rm=TRUE)) %>%
    arrange(avg_NoHealthIns) %>%
    head(10) %>%
    ggplot(aes(x=reorder(state, avg_NoHealthIns), y=avg_NoHealthIns)) +
    geom_bar(stat='identity', fill='skyblue') +
    coord_flip() +
    labs(x='State', y='Average % No Health Insurance', title='Top 10 States with Lowest Rates % of No Health Insurance')
```


## Median Home Value Specific EDA
### Median Home Value various visuals
```{r}
summary(cdc$MedHomeValue)
hist(cdc$"MedHomeValue")

# Calculate the median home value for each UrbanRural status
avg_MedHomeValue_urbanrural <- cdc %>%
  group_by(UrbanRural) %>%
  summarise(avg_MedHomeValue = mean(MedHomeValue, na.rm = TRUE))

# Print the result
print(avg_MedHomeValue_urbanrural)

# Plot a bar graph
ggplot(avg_MedHomeValue_urbanrural, aes(x=UrbanRural, y=avg_MedHomeValue)) +
  geom_bar(stat='identity', fill='skyblue') +
  labs(x='UrbanRural Status', y='MedHomeValue %', title='MedHomeValue for Each UrbanRural Status')


#looked at CHD vs MedHomeValue
ggplot(data = cdc, aes(x = `CHD`, y = `MedHomeValue`, fill = `CHD`)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "CHD", y = "MedHomeValue", fill = "CHD") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


### Top 10 Counties with highest MedHomeValue
```{r}
highest_10 <- cdc %>%
  arrange(desc(MedHomeValue)) %>%
  head(10)
highest_10
```


### Bottom 10 Counties with lowest MedHomeValue
```{r}
lowest_10 <- cdc %>%
    arrange(MedHomeValue) %>%
    head(10)
lowest_10
```


### Density plot for MedHomeValue UrbanRural
```{r}

ggplot(cdc, aes(x = MedHomeValue, fill = UrbanRural)) +
  geom_density(alpha = 0.5) +
  labs(x = "MedHomeValue", y = "Density") +
  theme_minimal() +
  scale_fill_brewer(palette = "Dark2")

library(corrplot)

correlation_matrix <- cor(cdc[, c("MedHomeValue", "CHD")])
corrplot(correlation_matrix, method = "number")



# Create a plot for each UrbanRural category
for(category in unique(cdc$UrbanRural)) {
  data_subset <- subset(cdc, UrbanRural == category)

  # Calculate correlation
  correlation <- round(cor(data_subset$MedHomeValue, data_subset$CHD, use = "pairwise.complete.obs"), 2)

  # Create the plot
  p <- ggplot(data_subset, aes(x = MedHomeValue, y = CHD)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "dashed") +
    geom_text(aes(label = paste("Correlation = ", correlation), x = Inf, y = Inf), hjust = "right", vjust = "top") +
    labs(title = paste("UrbanRural category:", category), x = "MedHomeValue", y = "CHD") +
    theme_minimal()
  
  print(p)
}

```


### MedHomeValue Boxplot
```{r}
ggplot(cdc, aes(x=UrbanRural, y=MedHomeValue)) + geom_boxplot()

```


### Highest and Lowest States of MedHomeValue
```{r}
# Top 10 states with highest MedHomeValue
cdc %>%
    group_by(state) %>%
    summarise(avg_MedHomeValue = mean(MedHomeValue, na.rm=TRUE)) %>%
    arrange(desc(avg_MedHomeValue)) %>%
    head(10) %>%
    ggplot(aes(x=reorder(state, avg_MedHomeValue), y=avg_MedHomeValue)) +
    geom_bar(stat='identity', fill='skyblue') +
    coord_flip() +
    labs(x='State', y='MedHomeValue %', title='Top 10 States with Highest Rates of MedHomeValue')

# Bottom 10 states with lowest MedHomeValue
cdc %>%
    group_by(state) %>%
    summarise(avg_MedHomeValue = mean(MedHomeValue, na.rm=TRUE)) %>%
    arrange(avg_MedHomeValue) %>%
    head(10) %>%
    ggplot(aes(x=reorder(state, avg_MedHomeValue), y=avg_MedHomeValue)) +
    geom_bar(stat='identity', fill='skyblue') +
    coord_flip() +
    labs(x='State', y='Average MedHomeValue %', title='Top 10 States with Lowest MedHomeValue')
```


## Median Household Income Specific EDA
### Median Household Income various visuals
```{r}
summary(cdc$MedHouseIncome)
hist(cdc$"MedHouseIncome")

# Calculate the median household income for each UrbanRural status
avg_MedHouseIncome_urbanrural <- cdc %>%
  group_by(UrbanRural) %>%
  summarise(avg_MedHouseIncome = mean(MedHouseIncome, na.rm = TRUE))

# Print the result
print(avg_MedHouseIncome_urbanrural)

# Plot a bar graph
ggplot(avg_MedHouseIncome_urbanrural, aes(x=UrbanRural, y=avg_MedHouseIncome)) +
  geom_bar(stat='identity', fill='skyblue') +
  labs(x='UrbanRural Status', y='MedHouseIncome %', title='MedHouseIncome for Each UrbanRural Status')


#looked at CHD vs MedHouseIncome
ggplot(data = cdc, aes(x = `CHD`, y = `MedHouseIncome`, fill = `CHD`)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "CHD", y = "MedHouseIncome", fill = "CHD") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


### Top 10 Counties with highest MedHouseIncome
```{r}
highest_10 <- cdc %>%
  arrange(desc(MedHouseIncome)) %>%
  head(10)
highest_10
```


### Bottom 10 Counties with lowest MedHouseIncome
```{r}
lowest_10 <- cdc %>%
    arrange(MedHouseIncome) %>%
    head(10)
lowest_10
```


### Density plot for MedHouseIncome UrbanRural
```{r}

ggplot(cdc, aes(x = MedHouseIncome, fill = UrbanRural)) +
  geom_density(alpha = 0.5) +
  labs(x = "MedHouseIncome", y = "Density") +
  theme_minimal() +
  scale_fill_brewer(palette = "Dark2")

library(corrplot)

correlation_matrix <- cor(cdc[, c("MedHouseIncome", "CHD")])
corrplot(correlation_matrix, method = "number")



# Create a plot for each UrbanRural category
for(category in unique(cdc$UrbanRural)) {
  data_subset <- subset(cdc, UrbanRural == category)

  # Calculate correlation
  correlation <- round(cor(data_subset$MedHouseIncome, data_subset$CHD, use = "pairwise.complete.obs"), 2)

  # Create the plot
  p <- ggplot(data_subset, aes(x = MedHouseIncome, y = CHD)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "dashed") +
    geom_text(aes(label = paste("Correlation = ", correlation), x = Inf, y = Inf), hjust = "right", vjust = "top") +
    labs(title = paste("UrbanRural category:", category), x = "MedHouseIncome", y = "CHD") +
    theme_minimal()
  
  print(p)
}

```


### MedHouseIncome Boxplot
```{r}
ggplot(cdc, aes(x=UrbanRural, y=MedHouseIncome)) + geom_boxplot()

```


### Highest and Lowest States of MedHouseIncome
```{r}
# Top 10 states with highest MedHouseIncome
cdc %>%
    group_by(state) %>%
    summarise(avg_MedHouseIncome = mean(MedHouseIncome, na.rm=TRUE)) %>%
    arrange(desc(avg_MedHouseIncome)) %>%
    head(10) %>%
    ggplot(aes(x=reorder(state, avg_MedHouseIncome), y=avg_MedHouseIncome)) +
    geom_bar(stat='identity', fill='skyblue') +
    coord_flip() +
    labs(x='State', y='MedHouseIncome %', title='Top 10 States with Highest Rates of MedHouseIncome')

# Bottom 10 states with lowest MedHouseIncome
cdc %>%
    group_by(state) %>%
    summarise(avg_MedHouseIncome = mean(MedHouseIncome, na.rm=TRUE)) %>%
    arrange(avg_MedHouseIncome) %>%
    head(10) %>%
    ggplot(aes(x=reorder(state, avg_MedHouseIncome), y=avg_MedHouseIncome)) +
    geom_bar(stat='identity', fill='skyblue') +
    coord_flip() +
    labs(x='State', y='Average MedHouseIncome %', title='Top 10 States with Lowest MedHouseIncome')
```


## Poverty Specific EDA
### Poverty various visuals
```{r}
summary(cdc$Poverty)
hist(cdc$"Poverty")

# Calculate the % Poverty level for each UrbanRural status
avg_Poverty_urbanrural <- cdc %>%
  group_by(UrbanRural) %>%
  summarise(avg_Poverty = mean(Poverty, na.rm = TRUE))

# Print the result
print(avg_Poverty_urbanrural)

# Plot a bar graph
ggplot(avg_Poverty_urbanrural, aes(x=UrbanRural, y=avg_Poverty)) +
  geom_bar(stat='identity', fill='skyblue') +
  labs(x='UrbanRural Status', y='Poverty %', title='Poverty for Each UrbanRural Status')


#looked at CHD vs Poverty
ggplot(data = cdc, aes(x = `CHD`, y = `Poverty`, fill = `CHD`)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "CHD", y = "Poverty", fill = "CHD") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


### Top 10 Counties with highest % Poverty
```{r}
highest_10 <- cdc %>%
  arrange(desc(Poverty)) %>%
  head(10)
highest_10
```


### Bottom 10 Counties with lowest % Poverty
```{r}
lowest_10 <- cdc %>%
    arrange(Poverty) %>%
    head(10)
lowest_10
```


### Density plot for Poverty UrbanRural
```{r}

ggplot(cdc, aes(x = Poverty, fill = UrbanRural)) +
  geom_density(alpha = 0.5) +
  labs(x = "Poverty", y = "Density") +
  theme_minimal() +
  scale_fill_brewer(palette = "Dark2")

library(corrplot)

correlation_matrix <- cor(cdc[, c("Poverty", "CHD")])
corrplot(correlation_matrix, method = "number")



# Create a plot for each UrbanRural category
for(category in unique(cdc$UrbanRural)) {
  data_subset <- subset(cdc, UrbanRural == category)

  # Calculate correlation
  correlation <- round(cor(data_subset$Poverty, data_subset$CHD, use = "pairwise.complete.obs"), 2)

  # Create the plot
  p <- ggplot(data_subset, aes(x = Poverty, y = CHD)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "dashed") +
    geom_text(aes(label = paste("Correlation = ", correlation), x = Inf, y = Inf), hjust = "right", vjust = "top") +
    labs(title = paste("UrbanRural category:", category), x = "Poverty", y = "CHD") +
    theme_minimal()
  
  print(p)
}

```


### Poverty Boxplot
```{r}
ggplot(cdc, aes(x=UrbanRural, y=Poverty)) + geom_boxplot()

```


### Highest and Lowest States % of Poverty
```{r}
# Top 10 states with highest % Poverty
cdc %>%
    group_by(state) %>%
    summarise(avg_Poverty = mean(Poverty, na.rm=TRUE)) %>%
    arrange(desc(avg_Poverty)) %>%
    head(10) %>%
    ggplot(aes(x=reorder(state, avg_Poverty), y=avg_Poverty)) +
    geom_bar(stat='identity', fill='skyblue') +
    coord_flip() +
    labs(x='State', y='Poverty %', title='Top 10 States with Highest % of Poverty')

# Bottom 10 states with lowest % of Poverty
cdc %>%
    group_by(state) %>%
    summarise(avg_Poverty = mean(Poverty, na.rm=TRUE)) %>%
    arrange(avg_Poverty) %>%
    head(10) %>%
    ggplot(aes(x=reorder(state, avg_Poverty), y=avg_Poverty)) +
    geom_bar(stat='identity', fill='skyblue') +
    coord_flip() +
    labs(x='State', y='Average Poverty %', title='Top 10 States with Lowest % Poverty')
```

#.
# Statistical Analysis
#.

### Correlation Analysis
#### General Correlation Matrix
```{r}
cor_matrix <- cdc %>%
  select(c(5:66)) %>% cor() #(5:66) All excluding state and rural/urban hot coded
cor_matrix
#Interesting way to see this
#cor_matrix[abs(cor_matrix)<0.5]=""
#cor_matrix
```


### Correlation plots: CHD and Urban/Rural vs various factors
#### Prevalence of other heart conditions factors
```{r}
cdc %>%
    select("CHD",
           "HighBP",
           "Stroke",
           "UrbanRural") %>%
    ggpairs(mapping = aes(color = cdc$"UrbanRural", alpha = 0.5))

```


#### Hospitals and pharmacy access factors
```{r}
cdc %>%
    select("CHD",
            "Hospitals",
            "Pharmacies",
            "UrbanRural") %>%
    ggpairs(mapping = aes(color = cdc$"UrbanRural", alpha = 0.5))

```


#### Hospital services factors
```{r}
cdc %>%
    select("CHD",
            "HospCR",
            "HospCIC",
            "HospED",
#            "HospNeuro",
            "UrbanRural") %>%
    ggpairs(mapping = aes(color = cdc$"UrbanRural", alpha = 0.5))

```


#### Physician and specialist access factors
```{r}
cdc %>%
    select("CHD",
           "CardioPhys",
#           "Neurologists",
#           "NeuroSurgeons",
           "pcp",
           "UrbanRural") %>%
    ggpairs(mapping = aes(color = cdc$"UrbanRural", alpha = 0.5))

```


#### Various health care delivery and insurance factors
```{r}
cdc %>%
    select("CHD",
           "bpmUse",
           "CholScreen",
           "CholMedNonAdhear",
           "CholMedElegible",
           "cruParticipate",
#           "HealthIns",
           "UrbanRural") %>%
    ggpairs(mapping = aes(color = cdc$"UrbanRural", alpha = 0.5))

```


#### Various (physical activity/smoking) risk factors
```{r}
cdc %>%
    select("CHD",
           "PhysInactivity",
           "Smoker",
           "UrbanRural") %>%
    ggpairs(mapping = aes(color = cdc$"UrbanRural", alpha = 0.5))

```


#### Various (other diagnosed)risk factors
```{r}
cdc %>%
    select("CHD",
           "Diabetes",
           "HighChol",
           "Obesity",
           "UrbanRural") %>%
    ggpairs(mapping = aes(color = cdc$"UrbanRural", alpha = 0.5))

```


#### Various physical environment factors
```{r}
cdc %>%
    select("CHD",
           "AirQuality",
           "Parks",
           "UrbanRural") %>%
    ggpairs(mapping = aes(color = cdc$"UrbanRural", alpha = 0.5))

```


#### Various (income) social environmental factors
```{r}
cdc %>%
    select("CHD",
           "SNAPrecipients",
#           "IncomeInequality",
           "Poverty",
           "Unemploy",
           "UrbanRural") %>%
    ggpairs(mapping = aes(color = cdc$"UrbanRural", alpha = 0.5))
```


#### Various (Income Related) Matrix
```{r}
correlation_matrix <- cor(cdc[, c("MedHomeValue", "MedHouseIncome", "Poverty", "CHD")])
corrplot(correlation_matrix, method = "number")
```


#### Various (housing) social environmental factors
```{r}
cdc %>%
    select("CHD",
           "MedHomeValue",
           "MedHouseIncome",
           "Poverty",
           "UrbanRural") %>%
    ggpairs(mapping = aes(color = cdc$"UrbanRural", alpha = 0.5))
```


#### Various (Education) social environmental factors
```{r}
cdc %>%
    select("CHD",
           "Broadband",
#           "Computer",
           "EdLessColl",
#           "EdLessHigh",
           "UrbanRural") %>%
    ggpairs(mapping = aes(color = cdc$"UrbanRural", alpha = 0.5))
```


##### Density plot for EdLessCol by itself
```{r}

ggplot(cdc, aes(x = Broadband, fill = UrbanRural)) +
  geom_density(alpha = 0.5) +
  labs(x = "EdLessColl", y = "Density") +
  theme_minimal() +
  scale_fill_brewer(palette = "Dark2")

library(corrplot)

correlation_matrix <- cor(cdc[, c("EdLessColl", "CHD")])
corrplot(correlation_matrix, method = "number")



# Create a plot for each UrbanRural category
for(category in unique(cdc$UrbanRural)) {
  data_subset <- subset(cdc, UrbanRural == category)

  # Calculate correlation
  correlation <- round(cor(data_subset$EdLessColl, data_subset$CHD, use = "pairwise.complete.obs"), 2)

  # Create the plot
  p <- ggplot(data_subset, aes(x = EdLessColl, y = CHD)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "dashed") +
    geom_text(aes(label = paste("Correlation = ", correlation), x = Inf, y = Inf), hjust = "right", vjust = "top") +
    labs(title = paste("UrbanRural category:", category), x = "EdLessColl", y = "CHD") +
    theme_minimal()
  
  print(p)
}

```


### Correlation analysis between cardiovascular providers and coronary heart disease prevalence
```{r}
cor.test(cdc$CardioPhys, cdc$CHD)

```


#### CHD/cardiovascular physicians correlation analysis visualization
```{r}
cdc %>%
  filter(UrbanRural %in% c(unique(UrbanRural))) %>%
ggplot(aes(log(CardioPhys), CHD, color=UrbanRural)) +
geom_point(alpha=0.3)+
facet_wrap(~UrbanRural)+
geom_smooth(method = lm)

```


### Correlation analysis between primary care providers and coronary heart disease prevalence
```{r}
cor.test(cdc$pcp, cdc$CHD)

```


#### CHD/primary care physicians correlation analysis visualization
```{r}
cdc %>%
  filter(UrbanRural %in% c(unique(UrbanRural))) %>%
ggplot(aes(log(pcp), CHD, color=UrbanRural)) +
geom_point(alpha=0.3)+
facet_wrap(~UrbanRural)+
geom_smooth(method = lm)

```


### Correlation analysis between hospitals and coronary heart disease prevalence
```{r}
cor.test(cdc$Hospitals, cdc$CHD)

```


#### CHD/hospitals correlation analysis visualization
```{r}
cdc %>%
  filter(UrbanRural %in% c(unique(UrbanRural))) %>%
ggplot(aes(log(Hospitals), CHD, color=UrbanRural)) +
geom_point(alpha=0.3)+
facet_wrap(~UrbanRural)+
geom_smooth(method = lm)

```


### Correlation analysis between hospitals with cardiac intensive care centers and coronary heart disease prevalence
```{r}
cor.test(cdc$HospCIC, cdc$CHD)

```


#### CHD/cardiac intensive care centers correlation analysis visualization
```{r}
cdc %>%
  filter(UrbanRural %in% c(unique(UrbanRural))) %>%
ggplot(aes(log(HospCIC), CHD, color=UrbanRural)) +
geom_point(alpha=0.3)+
facet_wrap(~UrbanRural)+
geom_smooth(method = lm)

```


### Correlation analysis between hospitals with cardiac rehabilitation centers and coronary heart disease prevalence
```{r}
cor.test(cdc$HospCR, cdc$CHD)

```


#### CHD/hospitals with cardiac rehabilitation centers correlation analysis visualization
```{r}
cdc %>%
  filter(UrbanRural %in% c(unique(UrbanRural))) %>%
ggplot(aes(log(HospCR), CHD, color=UrbanRural)) +
geom_point(alpha=0.3)+
facet_wrap(~UrbanRural)+
geom_smooth(method = lm)

```


### Correlation analysis between pharmacies and coronary heart disease prevalence
```{r}
cor.test(cdc$Pharmacies, cdc$CHD)

```


#### CHD/pharmacies correlation analysis visualization
```{r}
cdc %>%
  filter(UrbanRural %in% c(unique(UrbanRural))) %>%
ggplot(aes(log(Pharmacies), CHD, color=UrbanRural)) +
geom_point(alpha=0.3)+
facet_wrap(~UrbanRural)+
geom_smooth(method = lm)

```


### Various (other) factors
```{r}
cdc %>%
    select("CHD",
           "pop",
           "AirQuality",
           "Parks",
           "Broadband",
           "EdLessColl",
           "UrbanRural") %>%
    ggpairs(mapping = aes(color = cdc$"UrbanRural", alpha = 0.5))

```


## Density and Correlations for individual features and CHD
#### Population
```{r}
ggplot(cdc, aes(x = pop, fill = UrbanRural)) +
  geom_density(alpha = 0.5) +
  labs(x = "Population", y = "Density") +
  theme_minimal() +
  scale_fill_brewer(palette = "Dark2")

library(corrplot)

correlation_matrix <- cor(cdc[, c("pop", "CHD")])
corrplot(correlation_matrix, method = "number")

# Create a plot for each UrbanRural category
for(category in unique(cdc$UrbanRural)) {
  data_subset <- subset(cdc, UrbanRural == category)

  # Calculate correlation
  correlation <- round(cor(data_subset$pop, data_subset$CHD, use = "pairwise.complete.obs"), 2)

  # Create the plot
  p <- ggplot(data_subset, aes(x = pop, y = CHD)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "dashed") +
    geom_text(aes(label = paste("Correlation = ", correlation), x = Inf, y = Inf), hjust = "right", vjust = "top") +
    labs(title = paste("UrbanRural category:", category), x = "pop", y = "CHD") +
    theme_minimal()
  
  print(p)
}

```


#### Air Quality
```{r}
ggplot(cdc, aes(x = AirQuality, fill = UrbanRural)) +
  geom_density(alpha = 0.5) +
  labs(x = "Air Quality", y = "Density") +
  theme_minimal() +
  scale_fill_brewer(palette = "Dark2")

library(corrplot)

correlation_matrix <- cor(cdc[, c("AirQuality", "CHD")])
corrplot(correlation_matrix, method = "number")

# Create a plot for each UrbanRural category
for(category in unique(cdc$UrbanRural)) {
  data_subset <- subset(cdc, UrbanRural == category)

  # Calculate correlation
  correlation <- round(cor(data_subset$AirQuality, data_subset$CHD, use = "pairwise.complete.obs"), 2)

  # Create the plot
  p <- ggplot(data_subset, aes(x = AirQuality, y = CHD)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "dashed") +
    geom_text(aes(label = paste("Correlation = ", correlation), x = Inf, y = Inf), hjust = "right", vjust = "top") +
    labs(title = paste("UrbanRural category:", category), x = "AirQuality", y = "CHD") +
    theme_minimal()
  
  print(p)
}

```


#### Parks
```{r}
ggplot(cdc, aes(x = Parks, fill = UrbanRural)) +
  geom_density(alpha = 0.5) +
  labs(x = "Parks", y = "Density") +
  theme_minimal() +
  scale_fill_brewer(palette = "Dark2")

library(corrplot)

correlation_matrix <- cor(cdc[, c("Parks", "CHD")])
corrplot(correlation_matrix, method = "number")

# Create a plot for each UrbanRural category
for(category in unique(cdc$UrbanRural)) {
  data_subset <- subset(cdc, UrbanRural == category)

  # Calculate correlation
  correlation <- round(cor(data_subset$Parks, data_subset$CHD, use = "pairwise.complete.obs"), 2)

  # Create the plot
  p <- ggplot(data_subset, aes(x = Parks, y = CHD)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "dashed") +
    geom_text(aes(label = paste("Correlation = ", correlation), x = Inf, y = Inf), hjust = "right", vjust = "top") +
    labs(title = paste("UrbanRural category:", category), x = "Parks", y = "CHD") +
    theme_minimal()
  
  print(p)
}

```


#### Broadband Access
```{r}
ggplot(cdc, aes(x = Broadband, fill = UrbanRural)) +
  geom_density(alpha = 0.5) +
  labs(x = "Broadband", y = "Density") +
  theme_minimal() +
  scale_fill_brewer(palette = "Dark2")

library(corrplot)

correlation_matrix <- cor(cdc[, c("Broadband", "CHD")])
corrplot(correlation_matrix, method = "number")

# Create a plot for each UrbanRural category
for(category in unique(cdc$UrbanRural)) {
  data_subset <- subset(cdc, UrbanRural == category)

  # Calculate correlation
  correlation <- round(cor(data_subset$Broadband, data_subset$CHD, use = "pairwise.complete.obs"), 2)

  # Create the plot
  p <- ggplot(data_subset, aes(x = Broadband, y = CHD)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "dashed") +
    geom_text(aes(label = paste("Correlation = ", correlation), x = Inf, y = Inf), hjust = "right", vjust = "top") +
    labs(title = paste("UrbanRural category:", category), x = "Broadband", y = "CHD") +
    theme_minimal()
  
  print(p)
}

```


#### Education Less Than College
```{r}
ggplot(cdc, aes(x = EdLessColl, fill = UrbanRural)) +
  geom_density(alpha = 0.5) +
  labs(x = "EdLessColl", y = "Density") +
  theme_minimal() +
  scale_fill_brewer(palette = "Dark2")

library(corrplot)

correlation_matrix <- cor(cdc[, c("EdLessColl", "CHD")])
corrplot(correlation_matrix, method = "number")

# Create a plot for each UrbanRural category
for(category in unique(cdc$UrbanRural)) {
  data_subset <- subset(cdc, UrbanRural == category)

  # Calculate correlation
  correlation <- round(cor(data_subset$EdLessColl, data_subset$CHD, use = "pairwise.complete.obs"), 2)

  # Create the plot
  p <- ggplot(data_subset, aes(x = EdLessColl, y = CHD)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "dashed") +
    geom_text(aes(label = paste("Correlation = ", correlation), x = Inf, y = Inf), hjust = "right", vjust = "top") +
    labs(title = paste("UrbanRural category:", category), x = "EdLessColl", y = "CHD") +
    theme_minimal()
  
  print(p)
}

```


#### Greater than 65 years old
```{r}
ggplot(cdc, aes(x = Age65Plus, fill = UrbanRural)) +
  geom_density(alpha = 0.5) +
  labs(x = "Age65Plus", y = "Density") +
  theme_minimal() +
  scale_fill_brewer(palette = "Dark2")

library(corrplot)

correlation_matrix <- cor(cdc[, c("Age65Plus", "CHD")])
corrplot(correlation_matrix, method = "number")

# Create a plot for each UrbanRural category
for(category in unique(cdc$UrbanRural)) {
  data_subset <- subset(cdc, UrbanRural == category)

  # Calculate correlation
  correlation <- round(cor(data_subset$Age65Plus, data_subset$CHD, use = "pairwise.complete.obs"), 2)

  # Create the plot
  p <- ggplot(data_subset, aes(x = Age65Plus, y = CHD)) +
    geom_point(alpha = 0.5) +
    geom_smooth(method = "lm", se = FALSE, color = "red", linetype = "dashed") +
    geom_text(aes(label = paste("Correlation = ", correlation), x = Inf, y = Inf), hjust = "right", vjust = "top") +
    labs(title = paste("UrbanRural category:", category), x = "Age65Plus", y = "CHD") +
    theme_minimal()

  print(p)
}

```


## Correlation analysis between CHD and various factors
#### Population
```{r}
cor.test(cdc$pop, cdc$CHD)

```


#### Air Quality
```{r}
cor.test(cdc$AirQuality, cdc$CHD)

```


#### Parks
```{r}
cor.test(cdc$Parks, cdc$CHD)

```


#### Broadband
```{r}
cor.test(cdc$Broadband, cdc$CHD)

```


#### Education Less Than College
```{r}
cor.test(cdc$EdLessColl, cdc$CHD)

```


#### Age over 65 years old
```{r}
cor.test(cdc$Age65Plus, cdc$CHD)

```


## Correlation Visualizations between CHD and various factors
#### Population
```{r}
cdc %>%
  filter(UrbanRural %in% c(unique(UrbanRural))) %>%
ggplot(aes(log(pop), CHD, color=UrbanRural)) +
geom_point(alpha=0.3)+
facet_wrap(~UrbanRural)+
geom_smooth(method = lm)

```


#### Air Quality
```{r}
cdc %>%
  filter(UrbanRural %in% c(unique(UrbanRural))) %>%
ggplot(aes(log(AirQuality), CHD, color=UrbanRural)) +
geom_point(alpha=0.3)+
facet_wrap(~UrbanRural)+
geom_smooth(method = lm)

```


#### Parks
```{r}
cdc %>%
  filter(UrbanRural %in% c(unique(UrbanRural))) %>%
ggplot(aes(log(Parks), CHD, color=UrbanRural)) +
geom_point(alpha=0.3)+
facet_wrap(~UrbanRural)+
geom_smooth(method = lm)

```


#### Broadband
```{r}
cdc %>%
  filter(UrbanRural %in% c(unique(UrbanRural))) %>%
ggplot(aes(log(Broadband), CHD, color=UrbanRural)) +
geom_point(alpha=0.3)+
facet_wrap(~UrbanRural)+
geom_smooth(method = lm)

```


#### Education Less Than College
```{r}
cdc %>%
  filter(UrbanRural %in% c(unique(UrbanRural))) %>%
ggplot(aes(log(EdLessColl), CHD, color=UrbanRural)) +
geom_point(alpha=0.3)+
facet_wrap(~UrbanRural)+
geom_smooth(method = lm)

```


#### Age Over 65 years old
```{r}
cdc %>%
  filter(UrbanRural %in% c(unique(UrbanRural))) %>%
ggplot(aes(log(Age65Plus), CHD, color=UrbanRural)) +
geom_point(alpha=0.3)+
facet_wrap(~UrbanRural)+
geom_smooth(method = lm)

```

#.
# Regreassion Analysis
#.

### Regression analysis for potential confounders.
```{r}
model <- lm(CHD ~ CardioPhys + Broadband + Smoker + UrbanRural, data = cdc)
summary(model)

```
#### Linear Model with CHD vs various features Explanation:
**Residuals:**
The "Residuals" section provides information about the errors or residuals of the model. Residuals are the differences between the actual observed values and the predicted values from the regression model. This section displays summary statistics of the residuals, including the minimum, first quartile (1Q), median, third quartile (3Q), and maximum values.
In your model, the minimum residual is -4.1947, the first quartile is -0.6105, the median is -0.0589, the third quartile is 0.5536, and the maximum residual is 6.8327.

**Coefficients:**
The "Coefficients" section provides the estimated coefficients of the independent variables in the linear regression model. Each coefficient represents the expected change in the dependent variable (CHD) associated with a one-unit change in the corresponding independent variable, while holding other variables constant.
For example, the estimated coefficient for "CardioPhys" is -0.005596, indicating that, on average, for each unit increase in the "CardioPhys" variable, the dependent variable "CHD" is expected to decrease by approximately 0.005596 units, assuming all other variables are held constant.

The "Estimate" column shows the estimated coefficient values, the "Std. Error" column provides the standard errors of the estimates, and the "t value" column gives the t-statistic for testing whether the coefficient is significantly different from zero. The "Pr(>|t|)" column represents the p-value associated with the t-statistic, indicating the statistical significance of the coefficient. Lower p-values indicate greater significance.

In your model, all the coefficients have p-values less than 0.05, denoted by three asterisks (***), indicating that all the variables are statistically significant in explaining the variation in the dependent variable.

**Residual standard error:**
The "Residual standard error" is an estimate of the standard deviation of the residuals. It represents the average amount by which the observed values deviate from the predicted values. In your model, the residual standard error is 1.029.

**Multiple R-squared and Adjusted R-squared:**
The "Multiple R-squared" is a measure of how well the linear regression model fits the data. It indicates the proportion of the variance in the dependent variable that is explained by the independent variables. In your model, the multiple R-squared value is 0.5756, meaning that approximately 57.56% of the variance in the dependent variable "CHD" is explained by the independent variables in the model.

The "Adjusted R-squared" adjusts the multiple R-squared value for the number of independent variables and the sample size. It penalizes the addition of irrelevant variables that do not contribute much to the model's explanatory power. The adjusted R-squared value in your model is 0.5748.

**F-statistic:**
The F-statistic is a measure of overall significance in the linear regression model. It tests the null hypothesis that all the coefficients in the model are equal to zero, indicating that none of the independent variables have a significant relationship with the dependent variable. A low p-value (typically below 0.05) suggests that the model as a whole is statistically significant.
In your model, the F-statistic is 708.3, and the associated p-value is < 2.2e-16, which is essentially zero. This extremely low p-value indicates that the overall model is statistically significant, and at least one of the independent variables has a significant relationship with the dependent variable.

In summary, the linear regression model explains approximately 57.56% of the variance in the dependent variable "CHD." The coefficients of the independent variables are statistically significant, indicating that they have a significant relationship with "CHD" when controlling for other variables in the model. The model as a whole is statistically significant, suggesting that it provides valuable information in predicting the dependent variable.


## Linear Model with various variables
### CHD, Population, Air Quality, Parks, Broadband Access, Education Less Than College, and Age greater than 65.
```{r}
# Fit models to each imputed dataset
models <- with(imputed_data, exp = lm(CHD ~ UrbanRural + pop + Broadband + AirQuality + EdLessColl + Parks + Age65Plus))

# Pool results
pooled_results <- pool(models)

# Print summary of pooled results
summary(pooled_results)

```


### CHD, Population,  Age greater than 65.
```{r}
# Fit models to each imputed dataset
models <- with(imputed_data, exp = lm(CHD ~ pop + Age65Plus))

# Pool results
pooled_results <- pool(models)

# Print summary of pooled results
summary(pooled_results)

```


### CHD, Broadband, Parks, Age greater than 65.
```{r}
# Fit models to each imputed dataset
models <- with(imputed_data, exp = lm(CHD ~ UrbanRural + Broadband + Parks + Age65Plus))

# Pool results
pooled_results <- pool(models)

# Print summary of pooled results
summary(pooled_results)

```


### CHD, Parks, Age greater than 65.
```{r}
# Fit models to each imputed dataset
models <- with(imputed_data, exp = lm(CHD ~ UrbanRural + Parks + Age65Plus))

# Pool results
pooled_results <- pool(models)

# Print summary of pooled results
summary(pooled_results)

```


### CHD, Air Quality, Age greater than 65.
```{r}
# Fit models to each imputed dataset
models <- with(imputed_data, exp = lm(CHD ~ UrbanRural + AirQuality + Age65Plus))

# Pool results
pooled_results <- pool(models)

# Print summary of pooled results
summary(pooled_results)

```


## Linear Model with interactions
### CHD, Population, Air Quality, Parks, Broadband Access, Education Less Than College, and Age greater than 65.
```{r}
# Fit models to each imputed dataset
models <- with(imputed_data, exp = lm(CHD ~ UrbanRural + pop + EdLessColl * Broadband + AirQuality * Parks + Age65Plus))

# Pool results
pooled_results <- pool(models)

# Print summary of pooled results
summary(pooled_results)

```


### CHD, Population,  Age greater than 65.
```{r}
# Fit models to each imputed dataset
models <- with(imputed_data, exp = lm(CHD ~ pop * Age65Plus))

# Pool results
pooled_results <- pool(models)

# Print summary of pooled results
summary(pooled_results)

```


### CHD, Broadband, Parks, Age greater than 65.
```{r}
# Fit models to each imputed dataset
models <- with(imputed_data, exp = lm(CHD ~ UrbanRural + Broadband * Parks * Age65Plus))

# Pool results
pooled_results <- pool(models)

# Print summary of pooled results
summary(pooled_results)

```


### CHD, Parks, Age greater than 65.
```{r}
# Fit models to each imputed dataset
models <- with(imputed_data, exp = lm(CHD ~ UrbanRural + Parks * Age65Plus))

# Pool results
pooled_results <- pool(models)

# Print summary of pooled results
summary(pooled_results)

```


### CHD, Air Quality, Age greater than 65.
```{r}
# Fit models to each imputed dataset
models <- with(imputed_data, exp = lm(CHD ~ UrbanRural + AirQuality * Age65Plus))

# Pool results
pooled_results <- pool(models)

# Print summary of pooled results
summary(pooled_results)

```

### Linear Model with CHD vs Urban Rural
```{r}
# Fit models to each imputed dataset
models <- with(imputed_data, exp = lm(CHD ~ UrbanRural))

# Pool results
pooled_results <- pool(models)

# Print summary of pooled results
summary(pooled_results)

```
#### Linear Model with CHD vs Urban Rural Explanation:
**Intercept (Large_Urban)**: In this model, "Large_Urban" is the reference category because it is represented by the intercept. The intercept's value of approximately 5.79 is the average CHD prevalence in "Large_Urban" areas (given that the CHD data and coefficients are in a format where this interpretation makes sense).

**LargeFringe_Urban**: The coefficient of approximately 1.01 suggests that, on average, the CHD prevalence in "LargeFringe_Urban" areas is estimated to be about 1.01 units higher than in "Large_Urban" areas.

**MediumSmall_Urban**: Similarly, the CHD prevalence in "MediumSmall_Urban" areas is estimated to be about 1.80 units higher than in "Large_Urban" areas.

**Rural**: Lastly, the CHD prevalence in "Rural" areas is estimated to be about 2.98 units higher than in "Large_Urban" areas.

For all categories of "UrbanRural", the p-values are less than 0.05, which suggests that the differences in CHD prevalence between "Large_Urban" areas and the other types of areas are statistically significant.

In other words, your model suggests that there is a significant association between the type of area and CHD prevalence. Specifically, all other types of areas have higher estimated CHD prevalence than "Large_Urban" areas.


### Linear Model CHD vs Urban Rural + HighBP
```{r}
# Fit models to each imputed dataset
models <- with(imputed_data, exp = lm(CHD ~ UrbanRural + HighBP))

# Pool results
pooled_results <- pool(models)

# Print summary of pooled results
summary(pooled_results)

```
#### Linear Model CHD vs Urban Rural + HighBP Explanation:
In your output, each row corresponds to a term in the model, and each column corresponds to an aspect of the term.

- **term**: This is the name of the variable in the model. "(Intercept)" refers to the model's intercept, or baseline outcome when all the predictors are 0. In your case, "UrbanRuralLargeFringe_Urban", "UrbanRuralMediumSmall_Urban", and "UrbanRuralRural" are dummy variables derived from the categorical variable "UrbanRural", and "HighBP" is a variable representing high blood pressure.

- **estimate**: This is the estimated coefficient for the term in the model. For example, the estimate for "HighBP" is 0.1983978. In the context of this model, it means that for each unit increase in "HighBP", we would expect an increase of 0.1983978 units in "CHD", holding all other variables constant.

- **std.error**: This is the standard error of the estimated coefficient. It measures the variability in the estimate. A smaller standard error means the estimate is more precise.

- **statistic**: This is the t-statistic for the term. It is the ratio of the estimate to the standard error. The t-statistic follows a t-distribution under the null hypothesis that the true coefficient is zero. A larger absolute value of the t-statistic means it is further from zero, which provides stronger evidence against the null hypothesis.

- **df**: This is the degrees of freedom for the t-statistic.

- **p.value**: This is the p-value for the hypothesis test of whether the coefficient is zero. A smaller p-value means there is stronger evidence against the null hypothesis, i.e., stronger evidence that the coefficient is not zero.

In your output, all the p-values are very small, which suggests that each term in the model is significantly related to "CHD". Specifically:

- For a county that's "UrbanRuralLargeFringe_Urban" versus "Large_Urban", the expected "CHD" increases by 0.2928782 units, holding all other variables constant.
- For a county that's "UrbanRuralMediumSmall_Urban" versus "Large_Urban", the expected "CHD" increases by 0.7978104 units, holding all other variables constant.
- For a county that's "UrbanRuralRural" versus "Large_Urban", the expected "CHD" increases by 1.4393493 units, holding all other variables constant.
- For each unit increase in "HighBP", the expected "CHD" increases by 0.1983978 units, holding all other variables constant.

Therefore, your model suggests that "HighBP" and "UrbanRural" are both significant predictors of "CHD", with "HighBP" being a particularly strong predictor given its large t-statistic. This matches with what you might expect given that high blood pressure is known to be a risk factor for coronary heart disease.


### Linear Model with various variables
```{r}
# Fit models to each imputed dataset
models <- with(imputed_data, exp = lm(CHD ~ UrbanRural + HighBP + Broadband + Smoker + EdLessColl + MedHouseIncome + Poverty)) 

# Pool results
pooled_results <- pool(models)

# Print summary of pooled results
summary(pooled_results)

```
#### Linear Model with various variables Explanation:
1. **(Intercept)**: The expected value of CHD when all predictor variables are zero. In practice, this might not be meaningful if zero is outside the range of your predictor variables.
   
2. **UrbanRuralLargeFringe_Urban**: This is the change in CHD expected with a change from Large Urban (the reference category) to Large Fringe Urban, keeping all other variables constant. The p-value is slightly more than 0.05, so this effect may not be statistically significant at the usual levels.
   
3. **UrbanRuralMediumSmall_Urban**: This is the change in CHD expected with a change from Large Urban to Medium or Small Urban. The positive coefficient and small p-value suggest this is associated with an increase in CHD, and this effect is statistically significant.
   
4. **UrbanRuralRural**: The expected change in CHD with a change from Large Urban to Rural. This is significantly associated with an increase in CHD.
   
5. **HighBP (High Blood Pressure)**: The expected change in CHD with a unit increase in HighBP. The positive coefficient and very small p-value suggest that higher blood pressure is significantly associated with higher CHD.

6. **Broadband**: I'm not sure what this variable represents, but its positive coefficient and small p-value suggest that an increase in Broadband is associated with an increase in CHD, assuming all other variables are held constant.

7. **Smoker**: This might represent whether the individual is a smoker or the proportion of smokers. The positive coefficient and small p-value suggest that smoking is significantly associated with higher CHD.

8. **EdLessColl (Education Less than College)**: This might represent individuals with less than college education. The positive coefficient and small p-value suggest that having less than college education is significantly associated with higher CHD.

9. **MedHouseIncome (Median Household Income)**: This might represent the median household income in an area. The negative coefficient and very small p-value suggest that higher median household income is significantly associated with lower CHD, assuming all other variables are held constant.

10. **Poverty**: This might represent the proportion of individuals in poverty in an area. The negative coefficient and small p-value suggest that higher poverty is significantly associated with lower CHD, which seems counterintuitive. It might be due to confounding variables or other complex relationships in your data. 

Remember, these interpretations are conditional on the other variables in the model. This means, for example, the effect of HighBP on CHD is estimated assuming all other variables (UrbanRural, Broadband, Smoker, EdLessColl, MedHouseIncome, Poverty) are held constant.

Also, all these interpretations are about associations, not causal relationships. Determining whether a relationship is causal is more complex and requires more than just statistical analysis.


### Linear Model with Poverty
```{r}
# Fit models to each imputed dataset
models <- with(imputed_data, exp = lm(CHD ~ UrbanRural + Poverty))

# Pool results
pooled_results <- pool(models)

# Print summary of pooled results
summary(pooled_results)
```
#### Linear Model with Poverty Explanation:
- **(Intercept)**: The expected value of CHD when all predictor variables are zero. In the context of your model, this would mean when `UrbanRural` is at its reference level (which I'm assuming is "Large_Urban") and `Poverty` is 0. It's unlikely that the zero value of Poverty has a practical interpretation in your context. So, the intercept here is more of a technical aspect of the model, rather than something you would interpret directly.

- **UrbanRuralLargeFringe_Urban**: This represents the expected change in CHD when the `UrbanRural` variable changes from "Large_Urban" to "LargeFringe_Urban", keeping the `Poverty` constant. The estimate of 1.441820 suggests that, on average, `CHD` is 1.441820 units higher in "LargeFringe_Urban" areas than in "Large_Urban" areas, when `Poverty` is the same in both areas. The p-value of 2.808080e-19 (very close to 0) suggests that this effect is statistically significant.

- **UrbanRuralMediumSmall_Urban**: This represents the expected change in CHD when `UrbanRural` changes from "Large_Urban" to "MediumSmall_Urban", with `Poverty` kept constant. The estimate suggests that, on average, `CHD` is 1.802180 units higher in "MediumSmall_Urban" areas than in "Large_Urban" areas when `Poverty` is the same. The p-value (1.664810e-31) indicates that this effect is statistically significant.

- **UrbanRuralRural**: This represents the expected change in CHD when `UrbanRural` changes from "Large_Urban" to "Rural", keeping `Poverty` constant. The estimate of 2.766099 suggests that `CHD` is, on average, 2.766099 units higher in "Rural" areas than in "Large_Urban" areas when `Poverty` is the same. The p-value (2.199503e-73) indicates this effect is statistically significant.

- **Poverty**: This represents the expected change in CHD for a one-unit increase in `Poverty`, keeping `UrbanRural` constant. The positive estimate of 0.122293 suggests that for each unit increase in `Poverty`, `CHD` increases, on average, by 0.122293 units. The p-value (5.782284e-167) indicates this effect is statistically significant.

Please note that these interpretations are based on associations, not causal relationships. The estimates give us the expected change in the outcome variable (CHD) for a unit change in the predictor variables, assuming all other predictors are held constant. However, they do not tell us whether changing the predictor variable would cause a change in the outcome. Also, be aware that other factors not included in the model could be confounding the relationships.


### Linear Model with interactions 
```{r}
# Fit models to each imputed dataset
models <- with(imputed_data, exp = lm(CHD ~ UrbanRural * HighBP + Smoker * MedHouseIncome + Broadband + EdLessColl + Poverty))

# Pool results
pooled_results <- pool(models)

# Print summary of pooled results
summary(pooled_results)

```
#### Linear Model with interactions explanation:
1. **Intercept:** The intercept of the model is approximately 2.89. In the context of this model, the intercept represents the expected value of CHD when all the predictor variables are 0. However, since some of your variables are categorical (UrbanRural), the interpretation of the intercept becomes less straightforward. 

2. **UrbanRural:** The coefficients for UrbanRural indicate the change in the expected value of CHD for a given level of UrbanRural compared to the reference level (which in this case is "Large_Urban"), while all other predictors remain constant. For example, for "MediumSmall_Urban", the expected CHD decreases by about 1.81 units compared to "Large_Urban", assuming all other variables stay constant. Keep in mind that this coefficient is not statistically significant as the p-value is larger than 0.05.

3. **HighBP:** HighBP is positively associated with CHD, with a one-unit increase in HighBP leading to a ~0.092 increase in the expected value of CHD, assuming all other variables stay constant.

4. **Smoker:** Being a smoker increases the expected value of CHD by about 0.15, assuming all other variables stay constant.

5. **MedHouseIncome:** The coefficient for MedHouseIncome is close to 0 and its p-value is greater than 0.05, suggesting that there is no significant linear relationship between MedHouseIncome and CHD when other variables are controlled.

6. **Broadband, EdLessColl, and Poverty:** Similar to HighBP and Smoker, Broadband and EdLessColl are positively associated with CHD while Poverty is negatively associated. The more detailed interpretation would be similar to what we've gone over for HighBP and Smoker.

7. **Interaction Terms:** The coefficients for the interaction terms represent how much the relationship between HighBP and CHD changes for different levels of UrbanRural and how much the relationship between Smoker and CHD changes for different levels of MedHouseIncome. For instance, the interaction term UrbanRuralMediumSmall_Urban:HighBP suggests that the effect of HighBP on CHD is 0.068 units higher in MediumSmall_Urban areas compared to Large_Urban areas. 

   The interpretation of interaction terms can be complex, especially when the variables involved are not continuous. The main point here is that the relationship between CHD and HighBP and between CHD and Smoker varies depending on the level of UrbanRural and MedHouseIncome, respectively.

Overall, this model provides a nuanced view of the factors influencing CHD. However, it's essential to remember that this is a statistical model that captures associations, not necessarily causal relationships. For instance, while Broadband is positively associated with CHD, we wouldn't conclude that increasing broadband availability causes an increase in coronary heart disease prevalence. The associations we observe could be influenced by a variety of other factors not included in the model.


### Linear model with all features versus CHD
```{r}
cdc_lm <- cdc %>% select (5:66,) #(5:66) All numeric excluding hot coded
#NOTE: Above changed from cdc_copy to cdc by Jesse after adding additional cols

model <- lm(CHD ~ ., data = cdc_lm)

model

summary(model)
```


## Decision Trees
#### Decision tree with all numeric values and State
```{r}
library(rpart)

cdc_test <- cdc %>% select (3, 5:66, ) #(3, 5:66, ) state, all numeric excl.hot code

cdc_test <- cdc_test %>% select(-c(Stroke, HighChol))

tree_model <- rpart(CHD ~ ., data=cdc_test)

library(rpart.plot)
rpart.plot(tree_model)

tree_model$variable.importance
```


#### Decision trees with variable importance
```{r}
library(rpart)
library(rpart.plot)

cdc_test <- cdc %>% select (3, 5:66, ) #(3, 5:66, ) state, all numeric excl.hot code

cdc_test <- cdc_test %>% select(-c(Stroke, HighChol, Smoker, HighBP))

tree_model <- rpart(CHD ~ ., data=cdc_test)

rpart.plot(tree_model)
tree_model$variable.importance

cdc_test <- cdc %>% select (5:66, ) #(5:66) All numeric excluding hot coded

cdc_test <- cdc_test %>% select(-c(Stroke, HighChol, Smoker, HighBP))

tree_model <- rpart(CHD ~ ., data=cdc_test)

rpart.plot(tree_model)
tree_model$variable.importance
```


#### Decision trees with interactions
```{r}
cdc_test <- cdc %>% select (3, 5:66, ) #(3, 5:66, ) state, all numeric excl.hot code

cdc_test <- cdc_test %>% select(-c(bpmUse, Age65Plus, Stroke, HighChol, Smoker, HighBP))

tree_model <- rpart(CHD ~ ., data=cdc_test)

rpart.plot(tree_model)
tree_model$variable.importance

modeltest <- lm(CHD ~ MedHouseIncome*EdLessColl*Broadband + bpmUse + Age65Plus + Stroke + HighChol + Smoker + HighBP, data=cdc)
summary(modeltest)
```

# .
# ????Saving for possible use later?????
# .
```{r}
# Splitting the data into training and testing sets
#library(caret)
#set.seed(123)  # For reproducibility
#train_indices <- createDataPartition(cdc$target_variable, p = 0.7, list = FALSE)
#train_data <- data[train_indices, ]
#test_data <- data[-train_indices, ]

```

```{r}
# Example of building a linear regression model using caret
#library(caret)
#set.seed(123)  # For reproducibility
#model <- train(target_variable ~ ., data = train_data, method = "lm")  # Replace 'target_variable' with #your target variable/column name

# Model evaluation
#predictions <- predict(model, newdata = test_data)

```

# .
# Feature Selection
# .

### PCA
#### Prepare data for principle component analysis
```{r}
# Remove non-numeric variables
cdc_pca <- cdc %>% 
  select(-c("fips", "county", "state", "UrbanRural"))

# Remove NAs
cdc_pca[is.na(cdc_pca)] <- 0

# Double check to see if all entries are finite
all(sapply(cdc_pca, is.finite))

```


#### Run PCA on the dataset
```{r results='hide'}
pr_cdc <- prcomp(x = cdc_pca, scale = T, center = T)

summary(pr_cdc)

```


#### Run PCA on the dataset without hot coded states
```{r}
#Drop non numeric variables (note, rural/urban has been hot coded)
cdc_pca2 <- cdc %>%
  select(c(5:70)) #(5:70) All excluding state and rural/urban hot coded
pr_pca2 <- prcomp(x = cdc_pca2, scale = T, center = T)

summary(pr_pca2)

```

# .
# Predictive Modeling
# .

## Random Forest Model
### Split the data into training and test sets
```{r}
set.seed(2112)
train_index <- sample(1:nrow(cdc), 0.7 * nrow(cdc))
train_set <- cdc[train_index, ]
test_set <- cdc[-train_index, ]

table(cdc$UrbanRural)

```


### Build a random forest model
```{r}
library(randomForest)

set.seed(2112)

model <- randomForest(CHD ~ Hospitals + Broadband + UrbanRural, data=train_set, ntree=100)

print(model)

```


### Predict on the test set
```{r}
predictions <- predict(model, test_set)

```


## Random Forest Model Predictions
### Policy intervention to increases the number of cardiovascular providers by 20% in rural areas
```{r}
data_simulation_cardio <- cdc
data_simulation_cardio[data_simulation_cardio$UrbanRural == 'Rural', 'CardioPhys'] <- data_simulation_cardio[data_simulation_cardio$UrbanRural == 'Rural', 'CardioPhys'] * 1.20

```


#### Use the model to predict outcomes with the simulated data
```{r}
predictions_simulation_cardio <- predict(model, data_simulation_cardio)

```


#### Compare the original predictions and the simulated predictions
```{r}
summary(predictions)
summary(predictions_simulation_cardio)

```




#.
#  NEW (Jesse) 
#.

## Logistic Regression
### Logistic Regression on state and urban/rural
```{r}
# Create new data frame to work with
cdc_logReg <- cdc %>% select(c(CHD, county, state, UrbanRural))

# Convert categorical variables to factors
cdc_logReg$state <- as.factor(cdc_logReg$state)
cdc_logReg$UrbanRural <- as.factor(cdc_logReg$UrbanRural)

# Convert CHD to binary
cdc_logReg$CHD_bi <- ifelse(cdc_logReg$CHD > 10.0, 1, 0)

# Perform logistic regression
model_logReg <- glm(CHD_bi ~ state + UrbanRural, data = cdc_logReg, family = binomial())

# Print the summary of the model
summary(model_logReg)

```
#### Logistical regression model with CHD vs state and urban/rural features Explanation:

The glm function is used for generalized linear models, with the family parameter set to "binomial()" indicating that we are fitting a logistic regression. The response variable is CHD_bi (binary Coronary Heart Disease), and the predictors are state and UrbanRural.

**Coefficients**
This section gives the results of the model fitting.

The "Estimate" column gives the estimated coefficients for the model. For example, the coefficient for stateAL is 1.850e+01. This coefficient is in log-odds units, so to interpret it, we need to exponentiate it. The exponentiated coefficient represents the odds ratio for a one-unit increase in the corresponding predictor variable, holding all other predictors constant.

The "Std. Error" column gives the standard error of the estimates. The larger the standard error, the less certain we are about our estimate of the coefficient.

The "z value" is the estimate divided by the standard error. This is a test statistic that follows a standard normal distribution under the null hypothesis.

The "Pr(>|z|)" column is the two-sided p-value associated with the observed value of the z-statistic. It's calculated under the null hypothesis of no effect (i.e., a coefficient of 0). If the p-value is small (usually  0.05), you can reject the null hypothesis and conclude that the predictor is having an effect on the response. However, in this case, all of the p-values are quite high, indicating that none of the predictors are statistically significant at the 0.05 level.

**Deviance Residuals**
The null deviance shows how well the response variable is predicted by a model that includes only the intercept. Lower numbers indicate a better fit. The residual deviance shows how well the response variable is predicted by the model when the predictors are included. Again, lower numbers are better.

In this case, the residual deviance is significantly lower than the null deviance, which suggests that the model with the predictors is a better fit than the null model.

**AIC**
The Akaike Information Criterion (AIC) is a measure of the relative quality of a statistical model, for a given set of data. As a method of model selection, AIC balances the complexity of a model against how well the model fits the data. The preferred model is the one with the minimum AIC. In this case, the AIC is 1725.1.

**Number of Fisher Scoring iterations**
This is the number of iterations it took for the algorithm to converge, or find the maximum likelihood estimates of the coefficients.

Overall, it appears that none of the predictors are statistically significant at the 0.05 level, according to the p-values. However, the model does a better job of predicting the response than a null model, according to the deviance. You might want to consider other predictors, or perhaps there are interactions between predictors that are not being considered in this model.


# Feature Selection
## Recursive Feature Elimination (RFE)
### Split data for training
```{r}
# set.seed(2112)
# 
# # Reduce initial number of features
# cdc_rfe <- cdc %>% select(-c(fips, pcp, PSP1k, CardioPhys, Cardio100k, Hosp100k, Pharm100k, pop, PopAllGenders, AIAN, ANHPI, Black, Hispanic, TwoPlus, OtherRace, White, 71:121))
# 
# trainIndex_RFE <- createDataPartition(cdc_rfe$CHD, p = .7, list = FALSE, times = 1)
# 
# cdcTrain_RFE <- cdc_rfe[ trainIndex_RFE,]
# cdcTest_RFE  <- cdc_rfe[-trainIndex_RFE,]
# 
# ### Establish control features
# ctrl_RFE <- rfeControl(functions=rfFuncs, method="cv", number=10)

```


### Perform RFE model
```{r}
# result <- rfe(cdcTrain_RFE[, -ncol(cdcTrain_RFE)], cdcTrain_RFE$CHD, sizes=c(1:ncol(cdcTrain_RFE)-1), rfeControl=ctrl_RFE)
# 
# print(result)

```
#### Recursive Feature Elimination (RFE) Explanation:
Your output from the rfe function shows the results of recursive feature elimination (RFE) for different numbers of predictor variables, where the number of variables used in each model is shown in the Variables column.

For each model, several performance metrics are calculated. Here's what each of these columns mean:

Variables: This is the number of predictor variables included in the model.

**RMSE:** This is the Root Mean Squared Error of the model. It's a commonly used measure of the differences between values predicted by the model and the values actually observed. Lower values of RMSE indicate better fit.

**Rsquared:** This is the R-squared of the model, also known as the coefficient of determination. It's a statistical measure that represents the proportion of the variance for a dependent variable that's explained by an independent variable or variables in a regression model. It ranges from 0 to 1, and a higher value generally indicates a better fit of the model.

**MAE:** This is the Mean Absolute Error of the model. It's the average of the absolute differences between the predicted and actual values. It measures the average magnitude of the errors in a set of predictions, without considering their direction. Like RMSE, lower values indicate better fit.

**RMSESD:** This is the standard deviation of the RMSE over the cross-validation folds. A lower value indicates that the model's performance is more consistent across different subsets of the data.

**RsquaredSD:* This is the standard deviation of the R-squared values over the cross-validation folds. A lower value indicates that the model's performance is more consistent across different subsets of the data.

From these results, you can see how the model performance changes as you include more predictor variables.

Looking at the output, it appears that the model performs extremely well with just one or two variables, achieving very high R-squared values and very low RMSE, MAE values. However, it's important to be cautious here, as these results might be too good to be true and could suggest overfitting. Overfitting is when the model learns the training data too well, to the point where it performs poorly on new, unseen data.

Additionally, the performance seems to decrease (i.e., RMSE and MAE increase, and Rsquared decreases) as more variables are added, up to a certain point, after which it starts to increase again. This could suggest that some of the variables are not useful for prediction and might even be detrimental.

However, the standard deviations (RMSESD, RsquaredSD) also increase as more variables are added, indicating that the model's performance becomes less consistent across different subsets of the data.

These results can help you decide how many and which variables to include in your final model. You might choose the model with the highest R-squared, or you might choose a simpler model if it performs almost as well. The choice depends on your specific goals and constraints, such as how important interpretability is and how much computational resources you have.

#### Variable results for RFE
```{r}

# print(result$variables)
# 
# print(result$optimum)
# 
# print(names(result))

```

#.
# JESSE NEW - BREAK
#.

## Predictions
### Policy intervention to increases the number of primary care providers by 20% in rural areas
```{r}
data_simulation_pcp <- cdc
data_simulation_pcp[data_simulation_pcp$UrbanRural == 'Rural', 'pcp'] <- data_simulation_pcp[data_simulation_pcp$UrbanRural == 'Rural', 'pcp'] * 1.20

```


#### Use the model to predict outcomes with the simulated data
```{r}
predictions_simulation_pcp <- predict(model, data_simulation_pcp)

```


#### Compare the original predictions and the simulated predictions
```{r}
summary(predictions)
summary(predictions_simulation_cardio)
summary(predictions_simulation_pcp)

```


### Policy intervention to increases the number of parks by 20% in rural areas
```{r}
data_simulation_Parks <- cdc
data_simulation_Parks[data_simulation_Parks$UrbanRural == 'Rural', 'Parks'] <- data_simulation_Parks[data_simulation_Parks$UrbanRural == 'Rural', 'Parks'] * 2

```


#### Use the model to predict outcomes with the simulated data
```{r}
predictions_simulation_parks <- predict(model, data_simulation_Parks)

```


#### Compare the original predictions and the simulated predictions
```{r}
summary(predictions)
summary(predictions_simulation_cardio)
summary(predictions_simulation_pcp)
summary(predictions_simulation_parks)

```

#.
# BREAK
#.

We will subset the dataset to include only the variables of interest:
# Subset the dataset
```{r}
cdc2 <- cdc[c("CHD", "pcp", "PhysInactivity", "Parks", "Broadband", "HealthIns")]

```
Now, let's split the data into training, testing, and holdout sets. We'll use 70% of the data for training, 15% for testing, and 15% for holdout:

# Set the seed for reproducibility
```{r}
set.seed(2112)

```


# Create indices for the data split
```{r}
trainIndex <- createDataPartition(cdc2$CHD, p = .7, list = FALSE, times = 1)
```


# Split the data
```{r}
train <- cdc2[trainIndex, ]
temp <- cdc2[-trainIndex, ]

```


# Further split the remaining data into test and holdout sets
```{r}
testIndex <- createDataPartition(temp$CHD, p = .5, list = FALSE, times = 1)
test <- temp[testIndex, ]
holdout <- temp[-testIndex, ]

```
Now, let's create the linear regression model using the training set:


# Create the linear regression model
```{r}
model <- lm(CHD ~ pcp * PhysInactivity * Parks * Broadband * HealthIns, data = train)

```
We can now use this model to make predictions on the test set:


# Make predictions on the test set
```{r}
predictions <- predict(model, newdata = test)

```
To compare the model's performance before and after increasing the 'Broadband' variable by 25%, we first need to create a new dataset with the increased 'Broadband' values:


# Create a new dataset with increased 'Broadband' values
```{r}
cdc_increased <- cdc2
cdc_increased$Broadband <- cdc_increased$Broadband * 1.25

```
Then, we split this new dataset into training, testing, and holdout sets, and create a new model:


# Split the new data
```{r}
train_increased <- cdc_increased[trainIndex, ]
temp_increased <- cdc_increased[-trainIndex, ]
test_increased <- temp_increased[testIndex, ]
holdout_increased <- temp_increased[-testIndex, ]

```


# Create the new model
```{r}
model_increased <- lm(CHD ~ pcp + PhysInactivity + Parks + Broadband + HealthIns, data = train_increased)

```


# Make predictions on the new test set
```{r}
predictions_increased <- predict(model_increased, newdata = test_increased)

```
Now, you can compare the performance of the two models using your preferred metrics (e.g., RMSE, R-squared, etc.). For example:


# Calculate RMSE for the original model
```{r}
rmse_original <- sqrt(mean((test$CHD - predictions)^2))

```


# Calculate RMSE for the new model
```{r}
rmse_increased <- sqrt(mean((test_increased$CHD - predictions_increased)^2))

```


# Print the RMSE values
```{r}
print(paste("RMSE for the original model: ", rmse_original))
print(paste("RMSE for the model with increased Broadband: ", rmse_increased))

```
Please note that this is a basic example and might need adjustments based on the specifics of your dataset and project. For example, you might need to handle missing values, outliers, or non-linear relationships between the variables. Also, linear regression assumes that the residuals are normally distributed and that there is a linear relationship between the predictors and the target variable, among other assumptions. You should check these assumptions when using linear regression.











# .
# REFERENCE INFORMATION
# .

## For name mapping see table "TableDesc"

## Abbreviation descriptions
BPM = Blood Pressure Medications
CDP = Cardiovascular Physician
CLM = Cholesterol lowering Medications
CRU = Cardiac Rehabilitation Use
CS = Cholesterol Screening
HCDI = Health Care Delivery and Insurance
hp = Hospitals and Pharmacies
PE = Physical Environment
PS = Physicians and Specialists
RF = Risk Factors
SE = Social Environment
SEED = Social, Economic, Environmental Data
Services-NS = Neurological Services
Services-ED = Emergency Department
Services-CIC = Cardiac Intensive Care
Services-CR = Cardiovascular Rehabilitation


#.
#  NEW(Isaac) 
#.

###This was just a base test to start, but got some warnings-mostly related to including variables that are highly correlated with each other (we knew that)
```{r}
cdc_index <- createDataPartition(cdc$CHD, p = 0.8, list = FALSE)
cdc_tr <- cdc[cdc_index, ]
cdc_te <- cdc[-cdc_index, ]
control <- trainControl(method="repeatedcv", number =5, repeats=3)
m1 <- train(CHD ~ ., data=cdc_tr, method="lm", trControl = control)
print(m1$resample)
m1

importance <- varImp(m1, scale=TRUE)
plot(importance)

```
###didn't work
```{r}
#cdc %>% select(5:66,) %>% names()

# First, calculate the correlation matrix:
#correlation_matrix <- cor(cdc)
correlation_matrix <- cdc %>% select(5:66,) %>% cor()

# Next, convert the matrix into a dataframe and only keep the upper triangle to avoid duplicate pairs:
correlation_df <- as.data.frame(as.table(correlation_matrix))
correlation_df <- subset(correlation_df, Var1 < Var2)

# Add an absolute value of correlation to the dataframe
correlation_df$abs_value = abs(correlation_df$Freq)

# Now, you can filter for high correlations and sort them:
high_correlations <- subset(correlation_df, abs_value > 0.75)
high_correlations <- high_correlations[order(-high_correlations$abs_value), ]

# Finally, view the high correlations, sorted in descending order:
print(high_correlations)

```
###Better way to see some correlations
```{r}
#experimenting removing all high correlations
# cdc2 <- cdc %>% select(5,9:11,13:17,20,21,23,25:32,34,35,40)

#see all the high >70% correlations non dummy's
#cdc2 <- cdc %>% select(5:70)

cdc2 <- cdc %>% select("UrbanRural", "CHD", "HighBP", "HighChol", "Stroke", "Diabetes", "Obesity", "PhysInactivity", "Smoker", "Age65Plus", "MedHouseIncome", "EdLessColl", "MedHomeValue", "HealthIns", "AirQuality", "Parks", "Broadband", "pcp", "CardioPhys", "Hospitals")

cdc2$UrbanRural <- ifelse(cdc$UrbanRural %in% c("Large_Urban", "LargeFringe_Urban", "MediumSmall_Urban"), 1, 0)

# Calculate the correlation matrix:
correlation_matrix <- cor(cdc2, use="pairwise.complete.obs") # Use pairwise.complete.obs to handle missing values

# Convert correlation matrix into a long format dataframe
correlation_df <- reshape2::melt(correlation_matrix)

# Create a column with absolute value of correlation
correlation_df$abs_correlation <- abs(correlation_df$value)

# Keep only correlations above a certain threshold and below 1, avoiding self-correlation
high_correlations <- subset(correlation_df, abs_correlation > 0.70 & abs_correlation < 1)

# Now you can order your data frame by descending correlation
high_correlations <- high_correlations[order(-high_correlations$abs_correlation), ]

# Print the sorted data frame
print(high_correlations)

```
### Better Way continued
```{r}
unique_rows <- high_correlations %>%
  distinct(value, .keep_all = TRUE)

print(unique_rows)

```
###Middle Correlations
```{r}
# Keep only correlations between certain thresholds (0.5 to 0.7 in this case), avoiding self-correlation
middle_correlations <- subset(correlation_df, abs_correlation >= 0.5 & abs_correlation <= 0.7)

# Order your data frame by descending correlation
middle_correlations <- middle_correlations[order(-middle_correlations$abs_correlation), ]

# Print the sorted data frame
print(middle_correlations)

unique_rows <- middle_correlations %>%
  distinct(value, .keep_all = TRUE)

print(unique_rows)
```


###another try at a basic model
```{r}
#this gets rmse .347
#cdc2 <- cdc %>% select(5:70)

#this gets rmse .35
cdc2 <- cdc %>% select(4:13,19,23:29,32,35,42)
#this is same as select(4:13,19,23:29,32,35,42) 
cdc2 <- cdc %>% select("UrbanRural", "CHD", "HighBP", "HighChol", "Stroke", "Diabetes", "Obesity", "PhysInactivity", "Smoker", "Age65Plus", "MedHouseIncome", "EdLessColl", "MedHomeValue", "HealthIns", "AirQuality", "Parks", "Broadband", "pcp", "CardioPhys", "Hospitals", "pop")



cdc2$UrbanRural <- ifelse(cdc$UrbanRural %in% c("Large_Urban", "LargeFringe_Urban", "MediumSmall_Urban"), 1, 0)

cdc_index <- createDataPartition(cdc2$CHD, p = 0.8, list = FALSE)
cdc_tr <- cdc2[cdc_index, ]
cdc_te <- cdc2[-cdc_index, ]
control <- trainControl(method="repeatedcv", number =5, repeats=3)
m1 <- train(CHD ~ ., data=cdc_tr, method="lm", trControl = control)
print(m1$resample)
m1

importance <- varImp(m1, scale=TRUE)
plot(importance)
```

```{r}
ggplot(cdc2, aes(x=Diabetes , y=CHD, color=UrbanRural)) + geom_point()
```

```{r}
cdc2 <- cdc %>% select(4:42,44,45)
cdc2$UrbanRural <- ifelse(cdc$UrbanRural %in% c("Large_Urban", "LargeFringe_Urban", "MediumSmall_Urban"), 1, 0)

# Get all column names
all_vars <- names(cdc2)

# Remove CHD and UrbanRural from your list of variables
all_vars <- all_vars[!all_vars %in% c("CHD", "UrbanRural")]

# Loop through each variable name and make a ggplot
for (var in all_vars) {
  # Save the plot as an object
  p <- ggplot(cdc2, aes_string(x=var, y="CHD", color="UrbanRural")) + 
       geom_point() +
       geom_smooth(method="lm", se=FALSE, aes(group=UrbanRural))
  
  # Print the plot
  print(p)
}


```
### High Chol scatter plots
```{r}
cdc2 <- cdc %>% select(4:42,44,45)
cdc2$UrbanRural <- ifelse(cdc$UrbanRural %in% c("Large_Urban", "LargeFringe_Urban", "MediumSmall_Urban"), 1, 0)

# Get all column names
all_vars <- names(cdc2)

# Remove CHD and UrbanRural from your list of variables
all_vars <- all_vars[!all_vars %in% c("HighChol", "UrbanRural")]

# Loop through each variable name and make a ggplot
for (var in all_vars) {
  # Save the plot as an object
  p <- ggplot(cdc2, aes_string(x=var, y="HighChol", color="UrbanRural")) + 
       geom_point() +
       geom_smooth(method="lm", se=FALSE, aes(group=UrbanRural))
  
  # Print the plot
  print(p)
}
```
### HighBP
```{r}
cdc2 <- cdc %>% select(4:42,44,45)
cdc2$UrbanRural <- ifelse(cdc$UrbanRural %in% c("Large_Urban", "LargeFringe_Urban", "MediumSmall_Urban"), 1, 0)

# Get all column names
all_vars <- names(cdc2)

# Remove CHD and UrbanRural from your list of variables
all_vars <- all_vars[!all_vars %in% c("HighBP", "UrbanRural")]

# Loop through each variable name and make a ggplot
for (var in all_vars) {
  # Save the plot as an object
  p <- ggplot(cdc2, aes_string(x=var, y="HighBP", color="UrbanRural")) + 
       geom_point() +
       geom_smooth(method="lm", se=FALSE, aes(group=UrbanRural))
  
  # Print the plot
  print(p)
}
```


```{r}
#RMSE .35
cdc2 <- cdc %>% select(c( "UrbanRural", "CHD",  "HighBP", "HighChol", "Stroke", "PhysInactivity", "Smoker", "Age65Plus", "MedHouseIncome", "Poverty", "Unemploy", "EdLessColl", "HealthIns", "AirQuality", "Broadband"))

cdc2$UrbanRural <- ifelse(cdc$UrbanRural %in% c("Large_Urban", "LargeFringe_Urban", "MediumSmall_Urban"), 1, 0)

cdc_index <- createDataPartition(cdc2$CHD, p = 0.8, list = FALSE)
cdc_tr <- cdc2[cdc_index, ]
cdc_te <- cdc2[-cdc_index, ]
control <- trainControl(method="repeatedcv", number =5, repeats=3)
m1 <- train(CHD ~ ., data=cdc_tr, method="lm", trControl = control)
print(m1$resample)
m1

importance <- varImp(m1, scale=TRUE)
plot(importance)
```
```{r}
#RMSE .368
cdc2 <- cdc %>% select(c("CHD",  "HighBP", "HighChol", "Stroke", "Smoker", "Age65Plus"))

# cdc2$UrbanRural <- ifelse(cdc$UrbanRural %in% c("Large_Urban", "LargeFringe_Urban", "MediumSmall_Urban"), 1, 0)

cdc_index <- createDataPartition(cdc2$CHD, p = 0.8, list = FALSE)
cdc_tr <- cdc2[cdc_index, ]
cdc_te <- cdc2[-cdc_index, ]
control <- trainControl(method="repeatedcv", number =5, repeats=3)
m1 <- train(CHD ~ ., data=cdc_tr, method="lm", trControl = control)
print(m1$resample)
m1

importance <- varImp(m1, scale=TRUE)
plot(importance)
```
```{r}
cdc2 <- cdc %>% select(4:40)

cdc2$UrbanRural <- ifelse(cdc$UrbanRural %in% c("Large_Urban", "LargeFringe_Urban", "MediumSmall_Urban"), 1, 0)

cdc_index <- createDataPartition(cdc2$CHD, p = 0.8, list = FALSE)
cdc_tr <- cdc2[cdc_index, ]
cdc_te <- cdc2[-cdc_index, ]
# control <- trainControl(method="repeatedcv", number =5, repeats=3)
# m1 <- train(CHD ~ ., data=cdc_tr, method="lm", trControl = control)
# print(m1$resample)
# m1


x<-select(cdc_tr,-CHD)
y<-cdc_tr$CHD

control <- rfeControl(functions = rfFuncs, method = "cv", number=2)

results <- rfe(x,y, sizes=c(1:3), rfeControl=control)

print(results)

predictors(results)

plot(results, type=c("g", "o"))

```


```{r}
library(moderndive)
m1 <- lm(CHD ~ Stroke, data=cdc)
get_regression_table(m1)
summary(m1)

m2 <- lm(CHD ~ Stroke+Age65Plus, data=cdc)
get_regression_table(m2)
summary(m2)

m3 <- lm(CHD ~ Stroke + Age65Plus + HighChol + Smoker + HighBP, data=cdc)
get_regression_table(m3)
summary(m3)

m4 <- lm(CHD ~ Stroke + Age65Plus + HighChol + Smoker + HighBP + EdLessColl*MedHouseIncome,  data=cdc2)
get_regression_table(m4)
summary(m4)


```
```{r}
library(randomForest)
library(rpart)

cdc2 <- cdc %>% select(2:42)
cdc_index <- createDataPartition(cdc2$CHD, p=0.80, list=FALSE)
train <- cdc2[cdc_index, ]
test <- cdc2[-cdc_index, ]

ctrl <- trainControl(method = "cv")

fit <- train(CHD ~ .,
             data = train,
             method = "rpart",
             trControl = ctrl)
fit

fit <- train(CHD ~ .,
             data = train,
             method = "rf",
             trControl = ctrl)
fit
```
```{r}
fit2 <- train(CHD ~ .,
             data = train,
             method = "rpart",
             trControl = ctrl,
             tuneLength = 15,
             )
fit2

library(rpart.plot)
rpart.plot(fit2$finalModel, type=2)
```

```{r}
variable_importance = varImp(fit, scale=FALSE)
plot(variable_importance, top=15)
```
```{r}
fit2$finalModel$variable.importance
```
###subsetting Rural - model
```{r}
cdc2 <- cdc %>% select(4:40)

cdc2$UrbanRural <- ifelse(cdc$UrbanRural %in% c("Large_Urban", "LargeFringe_Urban", "MediumSmall_Urban"), 1, 0)

cdc_index <- createDataPartition(cdc2$CHD, p = 0.8, list = FALSE)
cdc_tr <- cdc2[cdc_index, ]
cdc_te <- cdc2[-cdc_index, ]

cdc_tr_rural <- subset(cdc_tr, UrbanRural == 0)
cdc_tr_urban <- subset(cdc_tr, UrbanRural == 1)

# Define your predictors (x) and response variable (y) for the rural data
x_rural <- select(cdc_tr_rural, -CHD)
y_rural <- cdc_tr_rural$CHD

control <- rfeControl(functions = rfFuncs, method = "cv", number=2)

# Run rfe for the rural data
results_rural <- rfe(x_rural, y_rural, sizes=c(1:5), rfeControl=control)

# Print results
print(results_rural)

# Check the important predictors
predictors(results_rural)

plot(results, type=c("g", "o"))
```
### Subsetting Urban - model
```{r}
cdc2 <- cdc %>% select(4:40)

cdc2$UrbanRural <- ifelse(cdc$UrbanRural %in% c("Large_Urban", "LargeFringe_Urban", "MediumSmall_Urban"), 1, 0)

cdc_index <- createDataPartition(cdc2$CHD, p = 0.8, list = FALSE)
cdc_tr <- cdc2[cdc_index, ]
cdc_te <- cdc2[-cdc_index, ]

cdc_tr_rural <- subset(cdc_tr, UrbanRural == 0)
cdc_tr_urban <- subset(cdc_tr, UrbanRural == 1)

# Define your predictors (x) and response variable (y) for the urban data
x_urban <- select(cdc_tr_urban, -CHD)
y_urban <- cdc_tr_urban$CHD

control <- rfeControl(functions = rfFuncs, method = "cv", number=2)

# Run rfe for the urban data
results_urban <- rfe(x_urban, y_urban, sizes=c(1:5), rfeControl=control)

# Print results
print(results_urban)

# Check the important predictors
predictors(results_urban)

plot(results, type=c("g", "o"))

```
Now, to interpret these outputs:

In both cases, you have trained models with 1 to 36 variables (from only one variable in the model to all 36 variables in the model). The sizes argument in the rfe() function defined this.

In both models (rural and urban), the model with 36 variables was selected as the best model (marked with '*'). This was based on the lowest RMSE.

When comparing the rural and urban models, it appears that the model for the urban areas performs slightly better than the model for the rural areas, as it has a lower RMSE (0.3985 vs. 0.4062) and a higher R-squared (0.9314 vs. 0.9166). However, the difference is quite small and might not be significant.

Regarding the top predictors (variables that help predict CHD), it's interesting to note that for both rural and urban areas, "Stroke", "Age65Plus", "HighChol", and "Smoker" are in the top 5. This suggests that these variables are important in predicting CHD, regardless of whether the area is urban or rural. However, the importance of other variables might differ between urban and rural areas.

For example, "bpmUse" (I assume this refers to the use of blood pressure medication) is in the top 5 for both rural and urban, but "HighBP" (high blood pressure) is in the top 5 for rural areas but not for urban ones. This difference might suggest that the management of high blood pressure is more critical in rural areas when it comes to CHD.

When you look at the top variables in the full list of 36, you can see that some variables, like "AirQuality" and "Poverty", are more important in rural areas than in urban areas, while variables like "PhysInactivity" and "Unemploy" appear to be more significant in urban areas.

###Subsetting Rural 2
```{r}
cdc2 <- cdc %>% select(4:40)

cdc2$UrbanRural <- ifelse(cdc$UrbanRural %in% c("Large_Urban", "LargeFringe_Urban", "MediumSmall_Urban"), 1, 0)

cdc_index <- createDataPartition(cdc2$CHD, p = 0.8, list = FALSE)
cdc_tr <- cdc2[cdc_index, ]
cdc_te <- cdc2[-cdc_index, ]

cdc_tr_rural <- subset(cdc_tr, UrbanRural == 0)
cdc_tr_urban <- subset(cdc_tr, UrbanRural == 1)

# Define your predictors (x) and response variable (y) for the rural data
x_rural <- select(cdc_tr_rural, -CHD)
y_rural <- cdc_tr_rural$CHD

control <- rfeControl(functions = rfFuncs, method = "cv", number=2)

# Run rfe for the rural data
results_rural <- rfe(x_rural, y_rural, sizes=c(1:8), rfeControl=control)

# Print results
print(results_rural)

# Check the important predictors
predictors(results_rural)

plot(results, type=c("g", "o"))
```

### Subsetting Urban2 - model
```{r}
cdc2 <- cdc %>% select(4:40)

cdc2$UrbanRural <- ifelse(cdc$UrbanRural %in% c("Large_Urban", "LargeFringe_Urban", "MediumSmall_Urban"), 1, 0)

cdc_index <- createDataPartition(cdc2$CHD, p = 0.8, list = FALSE)
cdc_tr <- cdc2[cdc_index, ]
cdc_te <- cdc2[-cdc_index, ]

cdc_tr_rural <- subset(cdc_tr, UrbanRural == 0)
cdc_tr_urban <- subset(cdc_tr, UrbanRural == 1)

# Define your predictors (x) and response variable (y) for the urban data
x_urban <- select(cdc_tr_urban, -CHD)
y_urban <- cdc_tr_urban$CHD

control <- rfeControl(functions = rfFuncs, method = "cv", number=2)

# Run rfe for the urban data
results_urban <- rfe(x_urban, y_urban, sizes=c(1:8), rfeControl=control)

# Print results
print(results_urban)

# Check the important predictors
predictors(results_urban)

plot(results, type=c("g", "o"))

```










In these new outputs, you've trained models with 1 to 7 variables and then jumped to 36 variables for comparison. Again, the model with 7 variables is selected as the best model in both rural and urban cases (as indicated by the '*') based on the lowest RMSE.

Let's discuss the rural model first:

The top 7 variables are "Stroke", "Age65Plus", "HighChol", "HighBP", "bpmUse", "Smoker", and "EdLessColl". The model's performance in terms of RMSE, R-squared, and MAE has improved as you add more variables until it reaches 7. The RMSE decreases from 0.6448 (for 1 variable) to 0.3991 (for 7 variables). R-squared increases from 0.7876 to 0.9218, indicating that the model with 7 variables can explain more variation in the response variable. The model's MAE decreases as well, suggesting a better fit.

In the urban model:

The top 7 variables are "Stroke", "Age65Plus", "HighChol", "bpmUse", "HighBP", "EdLessColl", and "Smoker". The order is slightly different from the rural model, suggesting that different factors might be more important in urban areas compared to rural areas. The model's performance in terms of RMSE, R-squared, and MAE again improves as you add more variables until it reaches 7, just like in the rural model. The RMSE decreases from 0.6079 (for 1 variable) to 0.3819 (for 7 variables), and R-squared increases from 0.8218 to 0.9342. Again, the model's MAE decreases as more variables are added.

When comparing the rural and urban models, it seems that the urban model is performing slightly better, as its RMSE is lower (0.3819 vs. 0.3991), and R-squared is higher (0.9342 vs. 0.9218). However, the difference is quite small.

These results show that while the model with all 36 variables does perform well, a model with only the top 7 variables can achieve almost as good performance. This finding is important because simpler models (i.e., models with fewer variables) are often preferred in practice because they are easier to interpret and can avoid overfitting. 

In terms of variable importance, "Stroke", "Age65Plus", "HighChol", "HighBP", "bpmUse", "Smoker", and "EdLessColl" are the top variables in both rural and urban areas, suggesting that these variables are universally important in predicting CHD. 

Remember, the interpretation of these results should be made in the context of the data and subject area. While these models indicate these variables are important predictors of CHD, further research is needed to understand why they are important and how they might interact with each other.
#from 4026
```{r}
#this gets rmse .347
#cdc2 <- cdc %>% select(5:70)

#this gets rmse .35
cdc2 <- cdc %>% select(4:13,19,23:29,32,35,42)
#this is same as select(4:13,19,23:29,32,35,42) 
cdc2 <- cdc %>% select("UrbanRural", "CHD", "HighBP", "HighChol", "Diabetes", "Obesity", "PhysInactivity", "Smoker", "Age65Plus", "MedHouseIncome", "EdLessColl", "MedHomeValue", "HealthIns", "AirQuality", "Parks", "Broadband", "pcp", "CardioPhys", "Hospitals", "pop")



cdc2$UrbanRural <- ifelse(cdc$UrbanRural %in% c("Large_Urban", "LargeFringe_Urban", "MediumSmall_Urban"), 1, 0)

cdc_index <- createDataPartition(cdc2$CHD, p = 0.8, list = FALSE)
cdc_tr <- cdc2[cdc_index, ]
cdc_te <- cdc2[-cdc_index, ]
control <- trainControl(method="repeatedcv", number =5, repeats=3)
m1 <- train(CHD ~ ., data=cdc_tr, method="lm", trControl = control)
print(m1$resample)
m1

importance <- varImp(m1, scale=TRUE)
plot(importance)
```
